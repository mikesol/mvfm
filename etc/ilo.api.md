## API Report File for "ilo"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { default as postgres_2 } from 'postgres';

// @public (undocumented)
export function array(of: SchemaType): ArraySchema;

// @public (undocumented)
export interface ArraySchema {
    // (undocumented)
    readonly __tag: "array";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export interface ASTNode {
    // (undocumented)
    __id?: number;
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    kind: string;
}

// @public (undocumented)
export const boolean: PluginDefinition<BooleanMethods>;

// @public (undocumented)
export const booleanInterpreter: InterpreterFragment;

// @public (undocumented)
export type BooleanMethods = {};

// @public (undocumented)
export const bounded: PluginDefinition<BoundedMethods>;

// @public (undocumented)
export type BoundedMethods = {};

// @public
export function composeInterpreters(fragments: InterpreterFragment[]): (node: ASTNode) => Promise<unknown>;

// @public (undocumented)
export const control: PluginDefinition<ControlMethods>;

// @public (undocumented)
export interface ControlMethods {
    // (undocumented)
    each<T>(collection: Expr<T[]>, body: (item: Expr<T>) => void): void;
    // (undocumented)
    while(condition: Expr<boolean>): {
        body: (...statements: unknown[]) => void;
    };
}

// @public (undocumented)
export const coreInterpreter: InterpreterFragment;

// @public (undocumented)
export const eq: PluginDefinition<EqMethods>;

// @public (undocumented)
export const eqInterpreter: InterpreterFragment;

// @public (undocumented)
export interface EqMethods {
    // (undocumented)
    eq(a: Expr<number> | number, b: Expr<number> | number): Expr<boolean>;
    // (undocumented)
    eq(a: Expr<string> | string, b: Expr<string> | string): Expr<boolean>;
    // (undocumented)
    eq(a: Expr<boolean> | boolean, b: Expr<boolean> | boolean): Expr<boolean>;
    // (undocumented)
    neq(a: Expr<number> | number, b: Expr<number> | number): Expr<boolean>;
    // (undocumented)
    neq(a: Expr<string> | string, b: Expr<string> | string): Expr<boolean>;
    // (undocumented)
    neq(a: Expr<boolean> | boolean, b: Expr<boolean> | boolean): Expr<boolean>;
}

// @public (undocumented)
export const error: PluginDefinition<ErrorMethods>;

// @public (undocumented)
export const errorInterpreter: InterpreterFragment;

// @public (undocumented)
export interface ErrorMethods {
    attempt<T>(expr: Expr<T>): Expr<{
        ok: T | null;
        err: any | null;
    }>;
    fail(error: Expr<any> | any): Expr<never>;
    guard(condition: Expr<boolean>, error: Expr<any> | any): Expr<void>;
    orElse<T>(expr: Expr<T>, fallback: Expr<T> | T): Expr<T>;
    settle(...exprs: Expr<any>[]): Expr<{
        fulfilled: any[];
        rejected: any[];
    }>;
    // Warning: (ae-forgotten-export) The symbol "TryBuilder" needs to be exported by the entry point index.d.ts
    try<T>(expr: Expr<T>): TryBuilder<T>;
}

// Warning: (ae-forgotten-export) The symbol "ExprBase" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExprFields" needs to be exported by the entry point index.d.ts
//
// @public
export type Expr<T> = ExprBase<T> & ExprFields<T>;

// @public (undocumented)
export const fiber: PluginDefinition<FiberMethods>;

// @public (undocumented)
export const fiberInterpreter: InterpreterFragment;

// @public (undocumented)
export interface FiberMethods {
    // Warning: (ae-forgotten-export) The symbol "ParFn" needs to be exported by the entry point index.d.ts
    par: ParFn;
    race(...exprs: Expr<any>[]): Expr<any>;
    retry(expr: Expr<any>, opts: {
        attempts: number;
        delay?: number;
    }): Expr<any>;
    seq(...exprs: (Expr<any> | any)[]): Expr<any>;
    timeout(expr: Expr<any>, ms: number | Expr<number>, fallback: Expr<any> | any): Expr<any>;
}

// @public (undocumented)
export const heytingAlgebra: PluginDefinition<HeytingAlgebraMethods>;

// @public (undocumented)
export interface HeytingAlgebraMethods {
    // (undocumented)
    and(a: Expr<boolean>, b: Expr<boolean>): Expr<boolean>;
    // (undocumented)
    not(a: Expr<boolean>): Expr<boolean>;
    // (undocumented)
    or(a: Expr<boolean>, b: Expr<boolean>): Expr<boolean>;
}

// @public
export function ilo<P extends PluginDefinition<any>[]>(...plugins: P): {
    <S extends SchemaShape>(schema: S, fn: ($: CoreDollar<InferSchema<S>> & MergePlugins<P>) => Expr<any> | any): Program;
    <I = never>(fn: ($: CoreDollar<I> & MergePlugins<P>) => Expr<any> | any): Program;
};

// Warning: (ae-forgotten-export) The symbol "TagToType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InferSchema<S> = S extends SchemaTag ? TagToType<S> : S extends {
    __tag: "array";
    of: infer U;
} ? InferSchema<U>[] : S extends {
    __tag: "nullable";
    of: infer U;
} ? InferSchema<U> | null : S extends Record<string, unknown> ? {
    [K in keyof S]: InferSchema<S[K]>;
} : never;

// @public (undocumented)
export function inferType(node: ASTNode, impls: TraitImpl[], schema?: Record<string, unknown>): string | null;

// @public (undocumented)
export type Interpreter = (program: Program) => {
    run: (input: Record<string, unknown>) => Promise<unknown>;
};

// @public
export interface InterpreterFragment {
    // (undocumented)
    canHandle: (node: ASTNode) => boolean;
    // (undocumented)
    pluginName: string;
    // (undocumented)
    visit: (node: ASTNode, recurse: (node: ASTNode) => Promise<unknown>) => Promise<unknown>;
}

// @public (undocumented)
export const monoid: PluginDefinition<MonoidMethods>;

// @public (undocumented)
export type MonoidMethods = {};

// @public (undocumented)
export function nullable(of: SchemaType): NullableSchema;

// @public (undocumented)
export interface NullableSchema {
    // (undocumented)
    readonly __tag: "nullable";
    // (undocumented)
    readonly of: SchemaType;
}

// @public (undocumented)
export const num: PluginDefinition<NumMethods>;

// @public (undocumented)
export const numInterpreter: InterpreterFragment;

// @public (undocumented)
export interface NumMethods {
    // (undocumented)
    abs(a: Expr<number> | number): Expr<number>;
    // (undocumented)
    ceil(a: Expr<number> | number): Expr<number>;
    // (undocumented)
    div(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    // (undocumented)
    floor(a: Expr<number> | number): Expr<number>;
    // (undocumented)
    max(...values: (Expr<number> | number)[]): Expr<number>;
    // (undocumented)
    min(...values: (Expr<number> | number)[]): Expr<number>;
    // (undocumented)
    mod(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    // (undocumented)
    neg(a: Expr<number> | number): Expr<number>;
    // (undocumented)
    round(a: Expr<number> | number): Expr<number>;
    // (undocumented)
    sub(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
}

// @public (undocumented)
export const ord: PluginDefinition<OrdMethods>;

// @public (undocumented)
export const ordInterpreter: InterpreterFragment;

// @public (undocumented)
export interface OrdMethods {
    // (undocumented)
    compare(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    // (undocumented)
    gt(a: Expr<number> | number, b: Expr<number> | number): Expr<boolean>;
    // (undocumented)
    gte(a: Expr<number> | number, b: Expr<number> | number): Expr<boolean>;
    // (undocumented)
    lt(a: Expr<number> | number, b: Expr<number> | number): Expr<boolean>;
    // (undocumented)
    lte(a: Expr<number> | number, b: Expr<number> | number): Expr<boolean>;
}

// @public
type Plugin_2<T = any> = PluginDefinition<T> | (() => PluginDefinition<T>);
export { Plugin_2 as Plugin }

// @public
export interface PluginContext {
    emit: (node: ASTNode) => void;
    expr: <T>(node: ASTNode) => Expr<T>;
    inputSchema?: Record<string, unknown>;
    isExpr: (value: unknown) => value is Expr<unknown>;
    lift: <T>(value: T | Expr<T>) => Expr<T>;
    plugins: PluginDefinition[];
    _registry: Map<number, ASTNode>;
    statements: ASTNode[];
}

// @public (undocumented)
export interface PluginDefinition<T = any> {
    // (undocumented)
    build: (ctx: PluginContext) => T;
    // (undocumented)
    name: string;
    // (undocumented)
    nodeKinds: string[];
    // (undocumented)
    traits?: {
        eq?: TraitImpl;
        ord?: TraitImpl;
        semiring?: TraitImpl;
        heytingAlgebra?: TraitImpl;
        show?: TraitImpl;
        semigroup?: TraitImpl;
        monoid?: TraitImpl;
        bounded?: TraitImpl;
    };
}

// @public (undocumented)
export function postgres(config?: PostgresConfig | string): PluginDefinition<PostgresMethods>;

// @public (undocumented)
export interface PostgresClient {
    // (undocumented)
    begin<T>(fn: (tx: PostgresClient) => Promise<T>): Promise<T>;
    // (undocumented)
    cursor(sql: string, params: unknown[], batchSize: number, fn: (rows: unknown[]) => Promise<undefined | false>): Promise<void>;
    // (undocumented)
    query(sql: string, params: unknown[]): Promise<unknown[]>;
    // (undocumented)
    savepoint<T>(fn: (tx: PostgresClient) => Promise<T>): Promise<T>;
}

// @public (undocumented)
export interface PostgresConfig {
    // (undocumented)
    connectionString?: string;
    // (undocumented)
    database?: string;
    // (undocumented)
    host?: string;
    // (undocumented)
    max?: number;
    // (undocumented)
    password?: string;
    // (undocumented)
    port?: number;
    // (undocumented)
    ssl?: boolean | object;
    // (undocumented)
    transform?: {
        column?: {
            to?: string;
            from?: string;
        };
    };
    // (undocumented)
    username?: string;
}

// @public (undocumented)
export function postgresInterpreter(client: PostgresClient, outerFragments?: InterpreterFragment[]): InterpreterFragment;

// @public (undocumented)
export interface PostgresMethods {
    // Warning: (ae-forgotten-export) The symbol "PostgresSql" needs to be exported by the entry point index.d.ts
    sql: PostgresSql;
}

// @public
export interface Program {
    // (undocumented)
    ast: ASTNode;
    // (undocumented)
    hash: string;
    // (undocumented)
    inputSchema: Record<string, unknown>;
    // (undocumented)
    plugins: string[];
}

// @public (undocumented)
export function resolveSchemaType(node: ASTNode, schema?: Record<string, unknown>): string | null;

// @public (undocumented)
export type SchemaShape = Record<string, SchemaType>;

// @public (undocumented)
export type SchemaTag = "string" | "number" | "boolean" | "date" | "null";

// @public (undocumented)
export type SchemaType = SchemaTag | ArraySchema | NullableSchema | {
    readonly [key: string]: SchemaType;
};

// @public (undocumented)
export const semigroup: PluginDefinition<SemigroupMethods>;

// @public (undocumented)
export interface SemigroupMethods {
    // (undocumented)
    append(a: Expr<string> | string, b: Expr<string> | string): Expr<string>;
}

// @public (undocumented)
export const semiring: PluginDefinition<SemiringMethods>;

// @public (undocumented)
export interface SemiringMethods {
    // (undocumented)
    add(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    // (undocumented)
    mul(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
}

// @public (undocumented)
export const show: PluginDefinition<ShowMethods>;

// @public (undocumented)
export interface ShowMethods {
    // (undocumented)
    show(a: Expr<number> | number): Expr<string>;
    // (undocumented)
    show(a: Expr<string> | string): Expr<string>;
    // (undocumented)
    show(a: Expr<boolean> | boolean): Expr<string>;
}

// @public (undocumented)
export const st: PluginDefinition<StMethods>;

// @public (undocumented)
export interface StMethods {
    // (undocumented)
    let<T>(initial: Expr<T> | T): {
        get: () => Expr<T>;
        set: (value: Expr<T> | T) => void;
        push: (value: Expr<T>) => void;
    };
}

// @public (undocumented)
export const str: PluginDefinition<StrMethods>;

// @public (undocumented)
export const strInterpreter: InterpreterFragment;

// @public (undocumented)
export interface StrMethods {
    // (undocumented)
    concat(...parts: (Expr<string> | string)[]): Expr<string>;
    // (undocumented)
    endsWith(s: Expr<string> | string, suffix: Expr<string> | string): Expr<boolean>;
    // (undocumented)
    includes(haystack: Expr<string> | string, needle: Expr<string> | string): Expr<boolean>;
    // (undocumented)
    join(arr: Expr<string[]>, separator: Expr<string> | string): Expr<string>;
    // (undocumented)
    len(s: Expr<string> | string): Expr<number>;
    // (undocumented)
    lower(s: Expr<string> | string): Expr<string>;
    // (undocumented)
    replace(s: Expr<string> | string, search: Expr<string> | string, replacement: Expr<string> | string): Expr<string>;
    // (undocumented)
    slice(s: Expr<string> | string, start: Expr<number> | number, end?: Expr<number> | number): Expr<string>;
    // (undocumented)
    split(s: Expr<string> | string, delimiter: Expr<string> | string): Expr<string[]>;
    // (undocumented)
    startsWith(s: Expr<string> | string, prefix: Expr<string> | string): Expr<boolean>;
    str(strings: TemplateStringsArray, ...exprs: (Expr<any> | string | number)[]): Expr<string>;
    // (undocumented)
    trim(s: Expr<string> | string): Expr<string>;
    // (undocumented)
    upper(s: Expr<string> | string): Expr<string>;
}

// @public (undocumented)
export interface TraitImpl {
    // (undocumented)
    nodeKinds: Record<string, string>;
    // (undocumented)
    type: string;
}

// Warning: (ae-forgotten-export) The symbol "Sql" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TransactionSql" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export function wrapPostgresJs(sql: Sql | TransactionSql): PostgresClient;

// Warnings were encountered during analysis:
//
// dist/core.d.ts:178:5 - (ae-forgotten-export) The symbol "CoreDollar" needs to be exported by the entry point index.d.ts
// dist/core.d.ts:178:5 - (ae-forgotten-export) The symbol "MergePlugins" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
