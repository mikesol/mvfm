## API Report File for "@mvfm/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function array(of: SchemaType): ArraySchema;

// @public
export interface ArraySchema {
    // (undocumented)
    readonly __tag: "array";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export const boolean: PluginDefinition<BooleanMethods, {}, "boolean/and" | "boolean/or" | "boolean/not" | "boolean/eq" | "boolean/ff" | "boolean/tt" | "boolean/implies" | "boolean/show" | "boolean/top" | "boolean/bottom">;

// Warning: (ae-forgotten-export) The symbol "BooleanKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const booleanInterpreter: Interpreter<BooleanKinds>;

// @public
export type BooleanMethods = {};

// @public
export const bounded: PluginDefinition<any, {}, never>;

// @public
export interface BoundedFor<_T> {
}

// @public
export function checkCompleteness(interpreter: Interpreter, program: Program): void;

// @public (undocumented)
export function checkCompleteness(interpreter: Interpreter, root: TypedNode): void;

// @public
export const control: PluginDefinition<ControlMethods, {}, "control/each" | "control/while">;

// @public
export const controlInterpreter: Interpreter<"control/each" | "control/while">;

// @public
export interface ControlMethods {
    each<T>(collection: Expr<T[]> | T[], body: (item: Expr<T>) => void): void;
    while(condition: Expr<boolean>): {
        body: (fn: () => void) => void;
    };
}

// @public
export interface CoreBegin<T = unknown> extends TypedNode<T> {
    // (undocumented)
    kind: "core/begin";
    // (undocumented)
    result: TypedNode<T>;
    // (undocumented)
    steps: TypedNode[];
}

// @public
export interface CoreCond<T = unknown> extends TypedNode<T> {
    // (undocumented)
    else: TypedNode<T>;
    // (undocumented)
    kind: "core/cond";
    // (undocumented)
    predicate: TypedNode<boolean>;
    // (undocumented)
    then: TypedNode<T>;
}

// @public
export interface CoreInput extends TypedNode<unknown> {
    // (undocumented)
    __inputData?: unknown;
    // (undocumented)
    kind: "core/input";
}

// @public
export const coreInterpreter: Interpreter<"core/literal" | "core/input" | "core/prop_access" | "core/record" | "core/cond" | "core/begin" | "core/program" | "core/tuple" | "core/lambda_param">;

// @public
export interface CoreLambdaParam<T = unknown> extends TypedNode<T> {
    // (undocumented)
    __value?: T;
    // (undocumented)
    kind: "core/lambda_param";
}

// @public
export interface CoreLiteral<T = unknown> extends TypedNode<T> {
    // (undocumented)
    kind: "core/literal";
    // (undocumented)
    value: T;
}

// @public
export interface CoreProgram extends TypedNode<unknown> {
    // (undocumented)
    kind: "core/program";
    // (undocumented)
    result: TypedNode;
    // (undocumented)
    statements: TypedNode[];
}

// @public
export interface CorePropAccess<T = unknown> extends TypedNode<T> {
    // (undocumented)
    kind: "core/prop_access";
    // (undocumented)
    object: TypedNode<Record<string, unknown>>;
    // (undocumented)
    property: string;
}

// @public
export interface CoreRecord extends TypedNode<Record<string, unknown>> {
    // (undocumented)
    fields: Record<string, TypedNode>;
    // (undocumented)
    kind: "core/record";
}

// @public
export interface CoreTuple extends TypedNode<unknown[]> {
    // (undocumented)
    elements: TypedNode[];
    // (undocumented)
    kind: "core/tuple";
}

// @public
export function createFoldState(): FoldState;

// @public
export function createStInterpreter(): Interpreter<"st/let" | "st/get" | "st/set" | "st/push">;

// Warning: (ae-forgotten-export) The symbol "DefaultsArgs" needs to be exported by the entry point index.d.ts
//
// @public
export function defaults<const P extends readonly PluginInput[]>(app: {
    readonly plugins: P;
}, ...args: DefaultsArgs<P>): Interpreter<ExtractPluginKinds<P[number]>>;

// Warning: (ae-forgotten-export) The symbol "RejectAnyParam" needs to be exported by the entry point index.d.ts
//
// @public
export function defineInterpreter<K extends string>(): <T extends InterpreterHandlers<K>>(handlers: string extends K ? T : T & { [P in K]: P extends keyof T ? RejectAnyParam<P, T[P]> : never; }) => Interpreter<K>;

// @public
export function definePlugin<const Kinds extends readonly string[], T, Traits extends Record<string, unknown> = {}>(def: {
    name: string;
    nodeKinds: Kinds;
    build: (ctx: PluginContext) => T;
    defaultInterpreter?: () => Interpreter<string>;
    traits?: PluginDefinition<any, Traits, Kinds[number]>["traits"];
}): PluginDefinition<T, Traits, Kinds[number]>;

// @public
export const eq: PluginDefinition<any, {}, "eq/neq">;

// @public
export interface EqFor<T> {
    eq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    neq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const eqInterpreter: Interpreter<"eq/neq">;

// @public
export const error: PluginDefinition<ErrorMethods, {}, "error/try" | "error/fail" | "error/attempt" | "error/guard" | "error/settle">;

// @public
export const errorInterpreter: Interpreter<"error/try" | "error/fail" | "error/attempt" | "error/guard" | "error/settle">;

// @public
export interface ErrorMethods {
    attempt<T>(expr: Expr<T>): Expr<{
        ok: T | null;
        err: any | null;
    }>;
    fail(error: Expr<any> | any): Expr<never>;
    guard(condition: Expr<boolean>, error: Expr<any> | any): Expr<void>;
    orElse<T>(expr: Expr<T>, fallback: Expr<T> | T): Expr<T>;
    settle(...exprs: Expr<any>[]): Expr<{
        fulfilled: any[];
        rejected: any[];
    }>;
    // Warning: (ae-forgotten-export) The symbol "TryBuilder" needs to be exported by the entry point index.d.ts
    try<T>(expr: Expr<T>): TryBuilder<T>;
}

// @public
export function eval_<T>(node: TypedNode<T>): AsyncGenerator<TypedNode, T, unknown>;

// Warning: (ae-forgotten-export) The symbol "ExprBase" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExprFields" needs to be exported by the entry point index.d.ts
//
// @public
export type Expr<T> = ExprBase<T> & ExprFields<T>;

// @public
export type ExtractPluginKinds<P> = P extends PluginDefinition<any, any, infer K> ? K : P extends (...args: any[]) => PluginDefinition<any, any, infer K> ? K : never;

// @public
export const fiber: PluginDefinition<FiberMethods, {}, "fiber/par_map" | "fiber/race" | "fiber/timeout" | "fiber/retry">;

// Warning: (ae-forgotten-export) The symbol "FiberKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const fiberInterpreter: Interpreter<FiberKinds>;

// @public
export interface FiberMethods {
    // Warning: (ae-forgotten-export) The symbol "ParFn" needs to be exported by the entry point index.d.ts
    par: ParFn;
    race(...exprs: Expr<any>[]): Expr<any>;
    retry(expr: Expr<any>, opts: {
        attempts: number;
        delay?: number;
    }): Expr<any>;
    seq(first: Expr<any> | any, ...rest: (Expr<any> | any)[]): Expr<any>;
    timeout(expr: Expr<any>, ms: number | Expr<number>, fallback: Expr<any> | any): Expr<any>;
}

// @public
export function fold<K extends string>(interpreter: Interpreter<K>, program: Program<K>, state?: FoldState): Promise<unknown>;

// @public (undocumented)
export function fold<K extends string>(interpreter: Interpreter<K>, root: TypedNode, state?: FoldState): Promise<unknown>;

// @public (undocumented)
export function fold<K extends string>(program: Program<K>, interpreter: Interpreter<K>, state?: FoldState): Promise<unknown>;

// @public (undocumented)
export function fold<K extends string>(root: TypedNode, interpreter: Interpreter<K>, state?: FoldState): Promise<unknown>;

// @public
export function foldAST<K extends string>(interpreter: Interpreter<K>, program: Program<K>, state?: FoldState): Promise<unknown>;

// @public (undocumented)
export function foldAST<K extends string>(interpreter: Interpreter<K>, root: TypedNode, state?: FoldState): Promise<unknown>;

// @public
export interface FoldState {
    // (undocumented)
    cache: WeakMap<TypedNode, unknown>;
    // (undocumented)
    tainted: WeakSet<TypedNode>;
}

// @public
export type FoldYield = TypedNode | RecurseScopedEffect;

// @public
export type Handler<N extends TypedNode<any>> = N extends TypedNode<infer T> ? (node: N) => AsyncGenerator<FoldYield, T, unknown> : never;

// @public
export const heytingAlgebra: PluginDefinition<any, {}, never>;

// @public
export interface HeytingAlgebraFor<T> {
    and(a: Expr<T>, b: Expr<T>): Expr<T>;
    not(a: Expr<T>): Expr<T>;
    or(a: Expr<T>, b: Expr<T>): Expr<T>;
}

// Warning: (ae-forgotten-export) The symbol "TagToType" needs to be exported by the entry point index.d.ts
//
// @public
export type InferSchema<S> = S extends SchemaTag ? TagToType<S> : S extends {
    __tag: "array";
    of: infer U;
} ? InferSchema<U>[] : S extends {
    __tag: "nullable";
    of: infer U;
} ? InferSchema<U> | null : S extends Record<string, unknown> ? {
    [K in keyof S]: InferSchema<S[K]>;
} : never;

// @public
export function inferType(node: any, impls: TraitImpl[], schema?: Record<string, unknown>): string | null;

// @public
export function injectInput(program: Program, input: Record<string, unknown>): Program;

// @public
export function injectLambdaParam(node: any, name: string, value: unknown): void;

// @public
export type Interpreter<K extends string = string> = InterpreterHandlers<K> & {
    readonly [interpreterBrand]: K;
};

// Warning: (ae-forgotten-export) The symbol "AnyHandlerRecord" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InterpreterHandlers<K extends string> = string extends K ? AnyHandlerRecord : {
    [P in K]: P extends keyof NodeTypeMap ? Handler<NodeTypeMap[P]> : never;
};

// @public
export type IsAny<T> = 0 extends 1 & T ? true : false;

// @public
export const koan: {
    add: typeof add;
    boolLit: typeof boolLit;
    buildKindInputs: typeof buildKindInputs;
    buildLiftMap: typeof buildLiftMap;
    buildTraitMap: typeof buildTraitMap;
    createApp: typeof createApp;
    app: <Expr extends CExpr<unknown>>(expr: Expr) => AppResult<RegistryOf<readonly [{
    readonly name: "num";
    readonly ctors: {
    readonly add: typeof add;
    readonly mul: typeof mul;
    readonly sub: typeof sub;
    readonly numLit: typeof numLit;
    };
    readonly kinds: {
    readonly "num/literal": KindSpec<[], number>;
    readonly "num/add": KindSpec<[number, number], number>;
    readonly "num/mul": KindSpec<[number, number], number>;
    readonly "num/sub": KindSpec<[number, number], number>;
    readonly "num/eq": KindSpec<[number, number], boolean>;
    };
    readonly traits: {
    readonly eq: {
    readonly output: boolean;
    readonly mapping: {
    readonly number: "num/eq";
    };
    };
    };
    readonly lifts: {
    readonly number: "num/literal";
    };
    readonly nodeKinds: readonly ["num/literal", "num/add", "num/mul", "num/sub", "num/eq"];
    readonly defaultInterpreter: () => Interpreter_2;
    }, {
    readonly name: "str";
    readonly ctors: {
    readonly strLit: typeof strLit;
    };
    readonly kinds: {
    readonly "str/literal": KindSpec<[], string>;
    readonly "str/eq": KindSpec<[string, string], boolean>;
    };
    readonly traits: {
    readonly eq: {
    readonly output: boolean;
    readonly mapping: {
    readonly string: "str/eq";
    };
    };
    };
    readonly lifts: {
    readonly string: "str/literal";
    };
    readonly nodeKinds: readonly ["str/literal", "str/eq"];
    readonly defaultInterpreter: () => Interpreter_2;
    }, {
    readonly name: "bool";
    readonly ctors: {
    readonly boolLit: typeof boolLit;
    };
    readonly kinds: {
    readonly "bool/literal": KindSpec<[], boolean>;
    readonly "bool/eq": KindSpec<[boolean, boolean], boolean>;
    };
    readonly traits: {
    readonly eq: {
    readonly output: boolean;
    readonly mapping: {
    readonly boolean: "bool/eq";
    };
    };
    };
    readonly lifts: {
    readonly boolean: "bool/literal";
    };
    readonly nodeKinds: readonly ["bool/literal", "bool/eq"];
    readonly defaultInterpreter: () => Interpreter_2;
    }]>, Expr>;
    appS: <Expr extends CExpr<unknown>>(expr: Expr) => AppResult<RegistryOf<readonly [{
    readonly name: "num";
    readonly ctors: {
    readonly add: typeof add;
    readonly mul: typeof mul;
    readonly sub: typeof sub;
    readonly numLit: typeof numLit;
    };
    readonly kinds: {
    readonly "num/literal": KindSpec<[], number>;
    readonly "num/add": KindSpec<[number, number], number>;
    readonly "num/mul": KindSpec<[number, number], number>;
    readonly "num/sub": KindSpec<[number, number], number>;
    readonly "num/eq": KindSpec<[number, number], boolean>;
    };
    readonly traits: {
    readonly eq: {
    readonly output: boolean;
    readonly mapping: {
    readonly number: "num/eq";
    };
    };
    };
    readonly lifts: {
    readonly number: "num/literal";
    };
    readonly nodeKinds: readonly ["num/literal", "num/add", "num/mul", "num/sub", "num/eq"];
    readonly defaultInterpreter: () => Interpreter_2;
    }, {
    readonly name: "str";
    readonly ctors: {
    readonly strLit: typeof strLit;
    };
    readonly kinds: {
    readonly "str/literal": KindSpec<[], string>;
    readonly "str/eq": KindSpec<[string, string], boolean>;
    };
    readonly traits: {
    readonly eq: {
    readonly output: boolean;
    readonly mapping: {
    readonly string: "str/eq";
    };
    };
    };
    readonly lifts: {
    readonly string: "str/literal";
    };
    readonly nodeKinds: readonly ["str/literal", "str/eq"];
    readonly defaultInterpreter: () => Interpreter_2;
    }, {
    readonly name: "bool";
    readonly ctors: {
    readonly boolLit: typeof boolLit;
    };
    readonly kinds: {
    readonly "bool/literal": KindSpec<[], boolean>;
    readonly "bool/eq": KindSpec<[boolean, boolean], boolean>;
    };
    readonly traits: {
    readonly eq: {
    readonly output: boolean;
    readonly mapping: {
    readonly boolean: "bool/eq";
    };
    };
    };
    readonly lifts: {
    readonly boolean: "bool/literal";
    };
    readonly nodeKinds: readonly ["bool/literal", "bool/eq"];
    readonly defaultInterpreter: () => Interpreter_2;
    }, {
    readonly name: "structural";
    readonly ctors: {
    readonly point: typeof point;
    readonly line: line;
    readonly pair: pair;
    readonly add: typeof add;
    };
    readonly kinds: {
    readonly "geom/point": KindSpec<[{
    x: number;
    y: number;
    }], {
    x: number;
    y: number;
    }>;
    readonly "geom/line": KindSpec<[{
    start: {
    x: number;
    y: number;
    };
    end: {
    x: number;
    y: number;
    };
    }], {
    start: {
    x: number;
    y: number;
    };
    end: {
    x: number;
    y: number;
    };
    }>;
    readonly "data/pair": KindSpec<[[number, number]], [number, number]>;
    };
    readonly traits: {};
    readonly lifts: {};
    readonly nodeKinds: readonly ["geom/point", "geom/line", "data/pair"];
    }]>, Expr>;
    point: typeof point;
    deepThing: typeof deepThing;
    fold: typeof fold_2;
    VOLATILE_KINDS: Set<string>;
    defaults: typeof defaults_2;
    commit: typeof commit;
    gc: typeof gc_2;
    gcPreservingAliases: typeof gcPreservingAliases;
    name: typeof name_2;
    pipe: typeof pipe;
    eq: typeof eq_2;
    collectReachable: typeof collectReachable;
    liveAdj: typeof liveAdj;
    incrementId: typeof incrementId;
    isCExpr: typeof isCExpr;
    lt: typeof lt;
    mapWhere: typeof mapWhere;
    replaceWhere: typeof replaceWhere;
    wrapByName: typeof wrapByName;
    spliceWhere: typeof spliceWhere;
    dirty: typeof dirty;
    addEntry: typeof addEntry;
    removeEntry: typeof removeEntry;
    swapEntry: typeof swapEntry;
    rewireChildren: typeof rewireChildren;
    setRoot: typeof setRoot;
    makeCExpr: typeof makeCExpr;
    makeNExpr: typeof makeNExpr;
    mul: typeof mul;
    mvfmU: typeof mvfmU;
    not: typeof not;
    numLit: typeof numLit;
    strLit: typeof strLit;
    selectWhere: typeof selectWhere;
    sub: typeof sub;
    byKind: typeof byKind;
    byKindGlob: typeof byKindGlob;
    byName: typeof byName;
    hasChildCount: typeof hasChildCount;
    isLeaf: typeof isLeaf;
    and: typeof and;
    or: typeof or;
    boolPluginU: {
        readonly name: "bool";
        readonly ctors: {
            readonly boolLit: typeof boolLit;
        };
        readonly kinds: {
            readonly "bool/literal": KindSpec<[], boolean>;
            readonly "bool/eq": KindSpec<[boolean, boolean], boolean>;
        };
        readonly traits: {
            readonly eq: {
                readonly output: boolean;
                readonly mapping: {
                    readonly boolean: "bool/eq";
                };
            };
        };
        readonly lifts: {
            readonly boolean: "bool/literal";
        };
        readonly nodeKinds: readonly ["bool/literal", "bool/eq"];
        readonly defaultInterpreter: () => Interpreter_2;
    };
    numPluginU: {
        readonly name: "num";
        readonly ctors: {
            readonly add: typeof add;
            readonly mul: typeof mul;
            readonly sub: typeof sub;
            readonly numLit: typeof numLit;
        };
        readonly kinds: {
            readonly "num/literal": KindSpec<[], number>;
            readonly "num/add": KindSpec<[number, number], number>;
            readonly "num/mul": KindSpec<[number, number], number>;
            readonly "num/sub": KindSpec<[number, number], number>;
            readonly "num/eq": KindSpec<[number, number], boolean>;
        };
        readonly traits: {
            readonly eq: {
                readonly output: boolean;
                readonly mapping: {
                    readonly number: "num/eq";
                };
            };
        };
        readonly lifts: {
            readonly number: "num/literal";
        };
        readonly nodeKinds: readonly ["num/literal", "num/add", "num/mul", "num/sub", "num/eq"];
        readonly defaultInterpreter: () => Interpreter_2;
    };
    ordPlugin: {
        readonly name: "ord";
        readonly ctors: {
            readonly lt: typeof lt;
        };
        readonly kinds: {
            readonly "num/lt": KindSpec<[number, number], boolean>;
            readonly "str/lt": KindSpec<[string, string], boolean>;
        };
        readonly traits: {
            readonly lt: {
                readonly output: boolean;
                readonly mapping: {
                    readonly number: "num/lt";
                    readonly string: "str/lt";
                };
            };
        };
        readonly lifts: {};
        readonly nodeKinds: readonly ["num/lt", "str/lt"];
        readonly defaultInterpreter: () => Interpreter_2;
    };
    stdPlugins: readonly [{
        readonly name: "num";
        readonly ctors: {
            readonly add: typeof add;
            readonly mul: typeof mul;
            readonly sub: typeof sub;
            readonly numLit: typeof numLit;
        };
        readonly kinds: {
            readonly "num/literal": KindSpec<[], number>;
            readonly "num/add": KindSpec<[number, number], number>;
            readonly "num/mul": KindSpec<[number, number], number>;
            readonly "num/sub": KindSpec<[number, number], number>;
            readonly "num/eq": KindSpec<[number, number], boolean>;
        };
        readonly traits: {
            readonly eq: {
                readonly output: boolean;
                readonly mapping: {
                    readonly number: "num/eq";
                };
            };
        };
        readonly lifts: {
            readonly number: "num/literal";
        };
        readonly nodeKinds: readonly ["num/literal", "num/add", "num/mul", "num/sub", "num/eq"];
        readonly defaultInterpreter: () => Interpreter_2;
    }, {
        readonly name: "str";
        readonly ctors: {
            readonly strLit: typeof strLit;
        };
        readonly kinds: {
            readonly "str/literal": KindSpec<[], string>;
            readonly "str/eq": KindSpec<[string, string], boolean>;
        };
        readonly traits: {
            readonly eq: {
                readonly output: boolean;
                readonly mapping: {
                    readonly string: "str/eq";
                };
            };
        };
        readonly lifts: {
            readonly string: "str/literal";
        };
        readonly nodeKinds: readonly ["str/literal", "str/eq"];
        readonly defaultInterpreter: () => Interpreter_2;
    }, {
        readonly name: "bool";
        readonly ctors: {
            readonly boolLit: typeof boolLit;
        };
        readonly kinds: {
            readonly "bool/literal": KindSpec<[], boolean>;
            readonly "bool/eq": KindSpec<[boolean, boolean], boolean>;
        };
        readonly traits: {
            readonly eq: {
                readonly output: boolean;
                readonly mapping: {
                    readonly boolean: "bool/eq";
                };
            };
        };
        readonly lifts: {
            readonly boolean: "bool/literal";
        };
        readonly nodeKinds: readonly ["bool/literal", "bool/eq"];
        readonly defaultInterpreter: () => Interpreter_2;
    }];
    strPluginU: {
        readonly name: "str";
        readonly ctors: {
            readonly strLit: typeof strLit;
        };
        readonly kinds: {
            readonly "str/literal": KindSpec<[], string>;
            readonly "str/eq": KindSpec<[string, string], boolean>;
        };
        readonly traits: {
            readonly eq: {
                readonly output: boolean;
                readonly mapping: {
                    readonly string: "str/eq";
                };
            };
        };
        readonly lifts: {
            readonly string: "str/literal";
        };
        readonly nodeKinds: readonly ["str/literal", "str/eq"];
        readonly defaultInterpreter: () => Interpreter_2;
    };
};

// @public
export function mergeInterpreters<A extends string, B extends string>(a: Interpreter<A>, b: Interpreter<B>): Interpreter<A | B>;

// Warning: (ae-internal-missing-underscore) The name "MissingTraitError" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface MissingTraitError<_TraitName extends string, Hint extends string> {
    // @deprecated (undocumented)
    readonly __error: Hint;
}

// @public
export const monoid: PluginDefinition<any, {}, never>;

// @public
export interface MonoidFor<_T> {
}

// @public
export function mvfm<const P extends readonly PluginInput[]>(...plugins: P): {
    <S extends SchemaShape>(schema: S, fn: ($: CoreDollar<InferSchema<S>> & MergePlugins<FlattenPluginInputs<P>>) => Expr<any> | any): Program<ExtractPluginKinds<FlattenPluginInputs<P>[number]>>;
    <I = never>(fn: ($: CoreDollar<I> & MergePlugins<FlattenPluginInputs<P>>) => Expr<any> | any): Program<ExtractPluginKinds<FlattenPluginInputs<P>[number]>>;
} & {
    plugins: FlattenPluginInputs<P>;
};

// @public
export interface NodeTypeMap {
}

// @public
export function nullable(of: SchemaType): NullableSchema;

// @public
export interface NullableSchema {
    // (undocumented)
    readonly __tag: "nullable";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export const num: PluginDefinition<NumMethods, {}, "num/add" | "num/sub" | "num/mul" | "num/div" | "num/mod" | "num/compare" | "num/neg" | "num/abs" | "num/floor" | "num/ceil" | "num/round" | "num/min" | "num/max" | "num/eq" | "num/zero" | "num/one" | "num/show" | "num/top" | "num/bottom">;

// Warning: (ae-forgotten-export) The symbol "NumKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const numInterpreter: Interpreter<NumKinds>;

// @public
export interface NumMethods {
    abs(a: Expr<number> | number): Expr<number>;
    ceil(a: Expr<number> | number): Expr<number>;
    div(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    floor(a: Expr<number> | number): Expr<number>;
    max(...values: (Expr<number> | number)[]): Expr<number>;
    min(...values: (Expr<number> | number)[]): Expr<number>;
    mod(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    neg(a: Expr<number> | number): Expr<number>;
    round(a: Expr<number> | number): Expr<number>;
    sub(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
}

// @public
export const ord: PluginDefinition<any, {}, "ord/gt" | "ord/gte" | "ord/lt" | "ord/lte">;

// @public
export interface OrdFor<T> {
    compare(a: Expr<T> | T, b: Expr<T> | T): Expr<number>;
    gt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    gte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const ordInterpreter: Interpreter<"ord/gt" | "ord/gte" | "ord/lt" | "ord/lte">;

// @public
type Plugin_2<T = any, Traits extends Record<string, unknown> = {}> = PluginDefinition<T, Traits, string> | (() => PluginDefinition<T, Traits, string>);
export { Plugin_2 as Plugin }

// @public
export interface PluginContext {
    emit: (node: any) => void;
    expr: <T>(node: any) => Expr<T>;
    inputSchema?: Record<string, unknown>;
    isExpr: (value: unknown) => value is Expr<unknown>;
    lift: <T>(value: T | Expr<T>) => Expr<T>;
    plugins: PluginDefinition<any, Record<string, unknown>, string>[];
    _registry: Map<number, any>;
    statements: any[];
}

// @public
export interface PluginDefinition<T = any, Traits extends Record<string, unknown> = {}, K extends string = string> {
    // @internal
    readonly __traits?: Traits;
    // (undocumented)
    build: (ctx: PluginContext) => T;
    defaultInterpreter?: () => Interpreter<K>;
    // (undocumented)
    name: string;
    // (undocumented)
    nodeKinds: readonly K[];
    // (undocumented)
    traits?: {
        eq?: TraitImpl;
        ord?: TraitImpl;
        semiring?: TraitImpl;
        heytingAlgebra?: TraitImpl;
        show?: TraitImpl;
        semigroup?: TraitImpl;
        monoid?: TraitImpl;
        bounded?: TraitImpl;
    };
}

// @public
export type PluginInput = Plugin_2 | readonly PluginInput[];

// @public
export const prelude: readonly [PluginDefinition<NumMethods, {}, "num/add" | "num/sub" | "num/mul" | "num/div" | "num/mod" | "num/compare" | "num/neg" | "num/abs" | "num/floor" | "num/ceil" | "num/round" | "num/min" | "num/max" | "num/eq" | "num/zero" | "num/one" | "num/show" | "num/top" | "num/bottom">, PluginDefinition<StrMethods, {}, "str/template" | "str/concat" | "str/upper" | "str/lower" | "str/trim" | "str/slice" | "str/includes" | "str/startsWith" | "str/endsWith" | "str/split" | "str/join" | "str/replace" | "str/len" | "str/eq" | "str/show" | "str/append" | "str/mempty">, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, "eq/neq">, PluginDefinition<any, {}, "ord/gt" | "ord/gte" | "ord/lt" | "ord/lte">, PluginDefinition<any, {}, never>, PluginDefinition<BooleanMethods, {}, "boolean/and" | "boolean/or" | "boolean/not" | "boolean/eq" | "boolean/ff" | "boolean/tt" | "boolean/implies" | "boolean/show" | "boolean/top" | "boolean/bottom">, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, never>];

// @public
export interface Program<K extends string = string> {
    // (undocumented)
    readonly __kinds?: K;
    // (undocumented)
    ast: any;
    // (undocumented)
    hash: string;
    // (undocumented)
    inputSchema: Record<string, unknown>;
    // (undocumented)
    plugins: string[];
}

// @public
export function recurseScoped(child: TypedNode, bindings: ScopedBinding[]): RecurseScopedEffect;

// @public
export interface RecurseScopedEffect {
    // (undocumented)
    bindings: ScopedBinding[];
    // (undocumented)
    child: TypedNode;
    // (undocumented)
    type: "recurse_scoped";
}

// @public
export function resolveSchemaType(node: any, schema?: Record<string, unknown>): string | null;

// @public
export type SchemaShape = Record<string, SchemaType>;

// @public
export type SchemaTag = "string" | "number" | "boolean" | "date" | "null";

// @public
export type SchemaType = SchemaTag | ArraySchema | NullableSchema | {
    readonly [key: string]: SchemaType;
};

// @public
export interface ScopedBinding {
    // (undocumented)
    paramId: number;
    // (undocumented)
    value: unknown;
}

// @public
export const semigroup: PluginDefinition<any, {}, never>;

// @public
export interface SemigroupFor<T> {
    append(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// @public
export const semiring: PluginDefinition<any, {}, never>;

// @public
export interface SemiringFor<T> {
    add(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
    mul(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// @public
export const show: PluginDefinition<any, {}, never>;

// @public
export interface ShowFor<T> {
    show(a: Expr<T> | T): Expr<string>;
}

// @public
export const st: PluginDefinition<StMethods, {}, "st/let" | "st/get" | "st/set" | "st/push">;

// @public
export const stInterpreter: Interpreter<"st/let" | "st/get" | "st/set" | "st/push">;

// @public
export interface StMethods {
    let<T>(initial: Expr<T> | T): {
        get: () => Expr<T>;
        set: (value: Expr<T> | T) => void;
        push: (value: Expr<T>) => void;
    };
}

// @public
export const str: PluginDefinition<StrMethods, {}, "str/template" | "str/concat" | "str/upper" | "str/lower" | "str/trim" | "str/slice" | "str/includes" | "str/startsWith" | "str/endsWith" | "str/split" | "str/join" | "str/replace" | "str/len" | "str/eq" | "str/show" | "str/append" | "str/mempty">;

// Warning: (ae-forgotten-export) The symbol "StrKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const strInterpreter: Interpreter<StrKinds>;

// @public
export interface StrMethods {
    concat(...parts: (Expr<string> | string)[]): Expr<string>;
    endsWith(s: Expr<string> | string, suffix: Expr<string> | string): Expr<boolean>;
    includes(haystack: Expr<string> | string, needle: Expr<string> | string): Expr<boolean>;
    join(arr: Expr<string[]>, separator: Expr<string> | string): Expr<string>;
    len(s: Expr<string> | string): Expr<number>;
    lower(s: Expr<string> | string): Expr<string>;
    replace(s: Expr<string> | string, search: Expr<string> | string, replacement: Expr<string> | string): Expr<string>;
    slice(s: Expr<string> | string, start: Expr<number> | number, end?: Expr<number> | number): Expr<string>;
    split(s: Expr<string> | string, delimiter: Expr<string> | string): Expr<string[]>;
    startsWith(s: Expr<string> | string, prefix: Expr<string> | string): Expr<boolean>;
    str(strings: TemplateStringsArray, ...exprs: (Expr<any> | string | number)[]): Expr<string>;
    trim(s: Expr<string> | string): Expr<string>;
    upper(s: Expr<string> | string): Expr<string>;
}

// @public
export interface TraitImpl {
    // (undocumented)
    nodeKinds: Record<string, string>;
    // (undocumented)
    type: string;
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassMapping" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassMapping<T> {
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassSlot" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassSlot<Name extends string> {
    // (undocumented)
    readonly __typeclassSlot: Name;
}

// @public
export interface TypedNode<T = unknown> {
    // (undocumented)
    readonly __T?: T;
    // (undocumented)
    readonly kind: string;
}

// @public
export const VOLATILE_KINDS: Set<string>;

// Warnings were encountered during analysis:
//
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "CoreDollar" needs to be exported by the entry point index.d.ts
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "MergePlugins" needs to be exported by the entry point index.d.ts
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "FlattenPluginInputs" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:23:5 - (ae-forgotten-export) The symbol "add" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:24:5 - (ae-forgotten-export) The symbol "boolLit" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:25:5 - (ae-forgotten-export) The symbol "buildKindInputs" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:26:5 - (ae-forgotten-export) The symbol "buildLiftMap" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:27:5 - (ae-forgotten-export) The symbol "buildTraitMap" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:28:5 - (ae-forgotten-export) The symbol "createApp" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:29:5 - (ae-forgotten-export) The symbol "CExpr" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:29:5 - (ae-forgotten-export) The symbol "AppResult" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:29:5 - (ae-forgotten-export) The symbol "RegistryOf" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:33:13 - (ae-forgotten-export) The symbol "mul" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:34:13 - (ae-forgotten-export) The symbol "sub" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:35:13 - (ae-forgotten-export) The symbol "numLit" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:38:13 - (ae-forgotten-export) The symbol "KindSpec" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:56:9 - (ae-forgotten-export) The symbol "Interpreter_2" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:60:13 - (ae-forgotten-export) The symbol "strLit" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:177:13 - (ae-forgotten-export) The symbol "point" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:178:13 - (ae-forgotten-export) The symbol "line" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:179:13 - (ae-forgotten-export) The symbol "pair" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:216:5 - (ae-forgotten-export) The symbol "deepThing" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:217:5 - (ae-forgotten-export) The symbol "fold_2" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:219:5 - (ae-forgotten-export) The symbol "defaults_2" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:220:5 - (ae-forgotten-export) The symbol "commit" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:221:5 - (ae-forgotten-export) The symbol "gc_2" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:222:5 - (ae-forgotten-export) The symbol "gcPreservingAliases" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:223:5 - (ae-forgotten-export) The symbol "name_2" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:224:5 - (ae-forgotten-export) The symbol "pipe" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:225:5 - (ae-forgotten-export) The symbol "eq_2" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:226:5 - (ae-forgotten-export) The symbol "collectReachable" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:227:5 - (ae-forgotten-export) The symbol "liveAdj" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:228:5 - (ae-forgotten-export) The symbol "incrementId" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:229:5 - (ae-forgotten-export) The symbol "isCExpr" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:230:5 - (ae-forgotten-export) The symbol "lt" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:231:5 - (ae-forgotten-export) The symbol "mapWhere" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:232:5 - (ae-forgotten-export) The symbol "replaceWhere" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:233:5 - (ae-forgotten-export) The symbol "wrapByName" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:234:5 - (ae-forgotten-export) The symbol "spliceWhere" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:235:5 - (ae-forgotten-export) The symbol "dirty" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:236:5 - (ae-forgotten-export) The symbol "addEntry" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:237:5 - (ae-forgotten-export) The symbol "removeEntry" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:238:5 - (ae-forgotten-export) The symbol "swapEntry" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:239:5 - (ae-forgotten-export) The symbol "rewireChildren" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:240:5 - (ae-forgotten-export) The symbol "setRoot" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:241:5 - (ae-forgotten-export) The symbol "makeCExpr" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:242:5 - (ae-forgotten-export) The symbol "makeNExpr" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:244:5 - (ae-forgotten-export) The symbol "mvfmU" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:245:5 - (ae-forgotten-export) The symbol "not" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:248:5 - (ae-forgotten-export) The symbol "selectWhere" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:250:5 - (ae-forgotten-export) The symbol "byKind" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:251:5 - (ae-forgotten-export) The symbol "byKindGlob" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:252:5 - (ae-forgotten-export) The symbol "byName" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:253:5 - (ae-forgotten-export) The symbol "hasChildCount" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:254:5 - (ae-forgotten-export) The symbol "isLeaf" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:255:5 - (ae-forgotten-export) The symbol "and" needs to be exported by the entry point index.d.ts
// dist/koan/index.d.ts:256:5 - (ae-forgotten-export) The symbol "or" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
