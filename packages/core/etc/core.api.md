## API Report File for "@mvfm/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function abs<A>(a: A): CExpr<number, "num/abs", [A]>;

// @public
export type AccessorOverlay<O> = O extends readonly (infer E)[] ? {
    readonly [k: number]: CExpr<E, "core/access">;
} : O extends object ? {
    readonly [K in keyof O]: CExpr<O[K], "core/access">;
} : {};

// @public
export function add<A, B>(a: A, b: B): CExpr<number, "num/add", [A, B]>;

// @public
export function addEntry<O, R extends string, Adj, C extends string, Id extends string, E extends NodeEntry<string, string[], any>>(d: DirtyExpr<O, R, Adj, C>, id: Id, entry: E): DirtyExpr<O, R, Adj & Record<Id, E>, C>;

// @public
export type AdjOf<E> = E extends NExpr<any, any, infer A, any> ? A : never;

// @public
export function and<A extends PredBase, B extends PredBase>(left: A, right: B): AndPred<A, B>;

// @public
export interface AndPred<A extends PredBase, B extends PredBase> extends PredBase {
    // (undocumented)
    readonly left: A;
    // (undocumented)
    readonly right: B;
    // (undocumented)
    readonly _tag: "and";
}

// @public
export function app<Expr extends CExpr<any, string, readonly unknown[]>, Reg = StdRegistry>(expr: Expr): AppResult<Reg, Expr>;

// @public
export type AppResult<Reg, Expr> = Expr extends CExpr<any, infer K extends string, infer A extends readonly unknown[]> ? NeverGuard<ElaborateExpr<Reg, K, A, {}, "a">, ElaborateExpr<Reg, K, A, {}, "a"> extends [
infer Adj,
infer C extends string,
infer R extends string,
infer O
] ? NExpr<O, R, Adj, C> : never> : never;

// @public
export function array(type: string): string;

// @public
export function boolAnd<A, B>(a: A, b: B): CExpr<boolean, "bool/and", [A, B]>;

// @public
export function boolLit<V extends boolean>(v: V): V;

// @public
export function boolNot<A>(a: A): CExpr<boolean, "bool/not", [A]>;

// @public
export function boolOr<A, B>(a: A, b: B): CExpr<boolean, "bool/or", [A, B]>;

// @public
const boolPlugin: {
    readonly name: "bool";
    readonly ctors: {
        readonly boolLit: typeof boolLit;
        readonly and: typeof boolAnd;
        readonly or: typeof boolOr;
        readonly not: typeof boolNot;
    };
    readonly kinds: {
        readonly "bool/literal": KindSpec<[], boolean>;
        readonly "bool/eq": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/neq": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/and": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/or": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/not": KindSpec<[boolean], boolean>;
        readonly "bool/implies": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/show": KindSpec<[boolean], string>;
        readonly "bool/tt": KindSpec<[], boolean>;
        readonly "bool/ff": KindSpec<[], boolean>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
            boolean: "bool/eq";
        }>;
        readonly neq: TraitDef<boolean, {
            boolean: "bool/neq";
        }>;
        readonly show: TraitDef<string, {
            boolean: "bool/show";
        }>;
    };
    readonly lifts: {
        readonly boolean: "bool/literal";
    };
    readonly nodeKinds: readonly ["bool/literal", "bool/eq", "bool/neq", "bool/and", "bool/or", "bool/not", "bool/implies", "bool/show", "bool/tt", "bool/ff"];
    readonly defaultInterpreter: () => Interpreter;
};
export { boolPlugin as _boolPluginDef }
export { boolPlugin }

// @public @deprecated (undocumented)
export const boolPluginU: {
    readonly name: "bool";
    readonly ctors: {
        readonly boolLit: boolLit;
        readonly and: boolAnd;
        readonly or: boolOr;
        readonly not: boolNot;
    };
    readonly kinds: {
        readonly "bool/literal": KindSpec<[], boolean>;
        readonly "bool/eq": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/neq": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/and": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/or": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/not": KindSpec<[boolean], boolean>;
        readonly "bool/implies": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/show": KindSpec<[boolean], string>;
        readonly "bool/tt": KindSpec<[], boolean>;
        readonly "bool/ff": KindSpec<[], boolean>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
        boolean: "bool/eq";
        }>;
        readonly neq: TraitDef<boolean, {
        boolean: "bool/neq";
        }>;
        readonly show: TraitDef<string, {
        boolean: "bool/show";
        }>;
    };
    readonly lifts: {
        readonly boolean: "bool/literal";
    };
    readonly nodeKinds: readonly ["bool/literal", "bool/eq", "bool/neq", "bool/and", "bool/or", "bool/not", "bool/implies", "bool/show", "bool/tt", "bool/ff"];
    readonly defaultInterpreter: () => Interpreter;
};

// @public
export function buildKindInputs(plugins: readonly Plugin_2[]): Record<string, string[]>;

// @public
export function buildLiftMap(plugins: readonly Plugin_2[]): Record<string, string>;

// @public
export function buildStructuralShapes(plugins: readonly Plugin_2[]): Record<string, unknown>;

// @public
export function buildTraitMap(plugins: readonly Plugin_2[]): Record<string, Record<string, string>>;

// @public
export function byKind<K extends string>(kind: K): KindPred<K>;

// @public
export function byKindGlob<P extends string>(prefix: P): KindGlobPred<P>;

// @public
export function byName<N extends string>(name: N): NamePred<N>;

// @public
export type CArgsOf<E> = E extends CExpr<any, any, infer A> ? A : never;

// @public
export function ceil<A>(a: A): CExpr<number, "num/ceil", [A]>;

// @public
export type CExpr<O, Kind extends string = string, Args extends readonly unknown[] = readonly unknown[]> = {
    readonly [cexprBrand]: {
        readonly o: O;
        readonly kind: Kind;
        readonly args: Args;
    };
    readonly [CREF]: true;
    readonly __kind: Kind;
    readonly __args: readonly unknown[];
    readonly __out: O;
} & AccessorOverlay<O>;

// @public
export type CKindOf<E> = E extends CExpr<any, infer K, any> ? K : never;

// @public
export type CollectReachable<Adj, Queue extends string[], Visited extends string = never> = Queue extends [infer Head extends string, ...infer Rest extends string[]] ? Head extends Visited ? CollectReachable<Adj, Rest, Visited> : Head extends keyof Adj ? Adj[Head] extends NodeEntry<any, infer C extends string[], any> ? CollectReachable<Adj, [...C, ...Rest], Visited | Head> : CollectReachable<Adj, Rest, Visited | Head> : CollectReachable<Adj, Rest, Visited | Head> : Visited;

// @public
export function collectReachable(adj: Record<string, RuntimeEntry>, rootId: string): Set<string>;

// @public
export function commit<O, R extends string, Adj, C extends string>(d: DirtyExpr<O, R, Adj, C>): NExpr<O, R, Adj, C>;

// @public
export function concat<A extends readonly unknown[]>(...args: A): CExpr<string, "str/concat", A>;

// @public
export const control: Plugin_2;

// @public
export const coreInterpreter: Interpreter;

// @public
export const corePlugin: Plugin_2;

// @public
export interface CountPred<N extends number> extends PredBase {
    // (undocumented)
    readonly count: N;
    // (undocumented)
    readonly _tag: "count";
}

// @public
export type COutOf<E> = E extends CExpr<infer O, any, any> ? O : never;

// @public
export function createApp<const P extends readonly Plugin_2[]>(...plugins: P): <Expr extends CExpr<any, string, readonly unknown[]>>(expr: Expr) => AppResult<RegistryOf<P>, Expr>;

// @public
export function createFoldState(): FoldState;

// @public
export const CREF: unique symbol;

// @public
export type CtrOf<E> = E extends NExpr<any, any, any, infer C> ? C : never;

// @public
export type DeepResolve<T> = T extends CExpr<infer O, any, any> ? O : T extends readonly [] ? [] : T extends readonly [infer H, ...infer Rest] ? [DeepResolve<H>, ...DeepResolve<Rest>] : T extends object ? {
    [K in keyof T]: DeepResolve<T[K]>;
} : T;

// @public
export function defaults(appOrPlugins: any, overrides?: Record<string, Interpreter>): Interpreter;

// Warning: (ae-forgotten-export) The symbol "InterpreterHandlers" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RejectAnyParam" needs to be exported by the entry point index.d.ts
//
// @public @deprecated (undocumented)
export function defineInterpreter<K extends string>(): <T extends InterpreterHandlers<K>>(handlers: string extends K ? T : T & { [P in K]: P extends keyof T ? RejectAnyParam<P, T[P]> : never; }) => Interpreter;

// @public @deprecated (undocumented)
export function definePlugin<T extends {
    name: string;
    nodeKinds: string[];
}>(def: T): T;

// @public
export function dirty<O, R extends string, Adj, C extends string>(expr: NExpr<O, R, Adj, C>): DirtyExpr<O, R, Adj, C>;

// @public
export type DirtyAdjOf<D> = D extends DirtyExpr<any, any, infer A, any> ? A : never;

// @public
export type DirtyCtrOf<D> = D extends DirtyExpr<any, any, any, infer C> ? C : never;

// @public
export interface DirtyExpr<O, RootId extends string, Adj, Ctr extends string> {
    // (undocumented)
    readonly [dirtyBrand]: {
        readonly o: O;
        readonly rootId: RootId;
        readonly adj: Adj;
        readonly ctr: Ctr;
    };
    // (undocumented)
    readonly __adj: Record<string, RuntimeEntry>;
    // (undocumented)
    readonly __counter: string;
    // (undocumented)
    readonly __id: string;
}

// @public
export type DirtyIdOf<D> = D extends DirtyExpr<any, infer R, any, any> ? R : never;

// @public
export type DirtyOutOf<D> = D extends DirtyExpr<infer O, any, any, any> ? O : never;

// @public
export function div<A, B>(a: A, b: B): CExpr<number, "num/div", [A, B]>;

// Warning: (ae-forgotten-export) The symbol "MergeCtors" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TraitCtors" needs to be exported by the entry point index.d.ts
//
// @public
export type DollarSign<P extends readonly Plugin_2[]> = MergeCtors<P> & TraitCtors<P>;

// Warning: (ae-forgotten-export) The symbol "ElaborateChildren" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ElaborateTraitExpr" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ElaborateExpr<Reg, Kind extends string, Args extends readonly unknown[], Adj, Ctr extends string> = Kind extends keyof Reg ? Reg[Kind] extends KindSpec<infer Inputs extends readonly unknown[], infer O> ? NeverGuard<ElaborateChildren<Reg, Args, Inputs, Adj, Ctr>, ElaborateChildren<Reg, Args, Inputs, Adj, Ctr> extends [
infer A2,
infer C2 extends string,
infer Ch
] ? [A2 & Record<C2, SNodeEntry<Kind, Ch, O>>, Increment<C2>, C2, O] : never> : Reg[Kind] extends TraitKindSpec<infer O, infer Mapping> ? ElaborateTraitExpr<Reg, O, Mapping, Args, Adj, Ctr> : never : never;

// @public
export function endsWith<A, B>(s: A, suffix: B): CExpr<boolean, "str/endsWith", [A, B]>;

// @public
export function eq<A, B>(a: A, b: B): CExpr<boolean, "eq", [A, B]>;

// @public
export const error: Plugin_2;

// @public @deprecated (undocumented)
export function eval_<T>(node: TypedNode<T>): AsyncGenerator<TypedNode, T, unknown>;

// @public
export type EvalPred<P, Entry, ID extends string = string, Adj = Record<string, any>> = P extends KindPred<infer K> ? Entry extends NodeEntry<K, any, any> ? true : false : P extends KindGlobPred<infer Prefix> ? Entry extends NodeEntry<`${Prefix}${string}`, any, any> ? true : false : P extends LeafPred ? Entry extends NodeEntry<any, [], any> ? true : false : P extends CountPred<infer N> ? Entry extends NodeEntry<any, infer C extends string[], any> ? C["length"] extends N ? true : false : false : P extends NotPred<infer Inner> ? EvalPred<Inner, Entry, ID, Adj> extends true ? false : true : P extends AndPred<infer A, infer B> ? EvalPred<A, Entry, ID, Adj> extends true ? EvalPred<B, Entry, ID, Adj> : false : P extends OrPred<infer A, infer B> ? EvalPred<A, Entry, ID, Adj> extends true ? true : EvalPred<B, Entry, ID, Adj> : P extends NamePred<infer N> ? Adj extends Record<`@${N}`, NodeEntry<any, [infer T extends string, ...any[]], any>> ? ID extends T ? true : false : false : false;

// @public @deprecated (undocumented)
export type Expr<T = unknown> = ExprBase<T>;

// @public @deprecated (undocumented)
export interface ExprBase<T> {
    // (undocumented)
    readonly [key: string]: unknown;
    // (undocumented)
    readonly __node: TypedNode<T>;
    // (undocumented)
    readonly __type: T;
}

// @public
export function extractChildIds(children: unknown): string[];

// @public
export const fiber: Plugin_2;

// @public
export function floor<A>(a: A): CExpr<number, "num/floor", [A]>;

// @public
export function fold(first: any, second: any, third?: any, fourth?: any): Promise<unknown>;

// @public @deprecated
export function foldAST<T>(interpOrProg: Interpreter | Record<string, unknown>, progOrInterp: unknown): Promise<T>;

// @public
export interface FoldState {
    // (undocumented)
    memo: Record<string, unknown>;
    // (undocumented)
    tainted: Set<string>;
}

// @public
export type FoldYield = number | string | RecurseScopedEffect;

// @public
function gc_2<O, R extends string, Adj, C extends string>(d: DirtyExpr<O, R, Adj, C>): DirtyExpr<O, R, LiveAdj<Adj, R>, C>;
export { gc_2 as gc }

// @public
export function gcPreservingAliases<O, R extends string, Adj, C extends string>(d: DirtyExpr<O, R, Adj, C>): DirtyExpr<O, R, LiveAdj<Adj, R> & PreserveAliases<Adj>, C>;

// @public
export type Handler = (entry: RuntimeEntry) => AsyncGenerator<FoldYield, unknown, unknown>;

// @public
export function hasChildCount<N extends number>(count: N): CountPred<N>;

// @public
export type IdOf<E> = E extends NExpr<any, infer R, any, any> ? R : never;

// @public
export function includes<A, B>(s: A, search: B): CExpr<boolean, "str/includes", [A, B]>;

// @public
export type Increment<S extends string> = S extends `${infer Rest}z` ? Rest extends "" ? "aa" : `${Increment<Rest>}a` : IncrementLast<S>;

// @public
export function incrementId(s: string): string;

// @public
export type IncrementLast<S extends string> = S extends `${infer R}a` ? `${R}b` : S extends `${infer R}b` ? `${R}c` : S extends `${infer R}c` ? `${R}d` : S extends `${infer R}d` ? `${R}e` : S extends `${infer R}e` ? `${R}f` : S extends `${infer R}f` ? `${R}g` : S extends `${infer R}g` ? `${R}h` : S extends `${infer R}h` ? `${R}i` : S extends `${infer R}i` ? `${R}j` : S extends `${infer R}j` ? `${R}k` : S extends `${infer R}k` ? `${R}l` : S extends `${infer R}l` ? `${R}m` : S extends `${infer R}m` ? `${R}n` : S extends `${infer R}n` ? `${R}o` : S extends `${infer R}o` ? `${R}p` : S extends `${infer R}p` ? `${R}q` : S extends `${infer R}q` ? `${R}r` : S extends `${infer R}r` ? `${R}s` : S extends `${infer R}s` ? `${R}t` : S extends `${infer R}t` ? `${R}u` : S extends `${infer R}u` ? `${R}v` : S extends `${infer R}v` ? `${R}w` : S extends `${infer R}w` ? `${R}x` : S extends `${infer R}x` ? `${R}y` : S extends `${infer R}y` ? `${R}z` : never;

// @public
export function injectInput(prog: Program, data: Record<string, unknown>): Program;

// @public
export type Interpreter = Record<string, Handler>;

// @public
export function isCExpr(x: unknown): x is CExpr<unknown>;

// @public
export function isLeaf(): LeafPred;

// @public
export function join<A, B>(arr: A, sep: B): CExpr<string, "str/join", [A, B]>;

// @public
export const KIND_INPUTS: Record<string, string[]>;

// @public
export interface KindGlobPred<P extends string> extends PredBase {
    // (undocumented)
    readonly prefix: P;
    // (undocumented)
    readonly _tag: "kindGlob";
}

// @public
export interface KindPred<K extends string> extends PredBase {
    // (undocumented)
    readonly kind: K;
    // (undocumented)
    readonly _tag: "kind";
}

// @public
export interface KindSpec<I extends readonly unknown[], O> {
    // (undocumented)
    readonly inputs: I;
    // (undocumented)
    readonly output: O;
}

// @public
export interface LeafPred extends PredBase {
    // (undocumented)
    readonly _tag: "leaf";
}

// @public
export function len<A>(s: A): CExpr<number, "str/len", [A]>;

// @public
export const LIFT_MAP: Record<string, string>;

// @public
export type LiftKind<T> = T extends number ? "num/literal" : T extends string ? "str/literal" : T extends boolean ? "bool/literal" : never;

// @public
export type LiveAdj<Adj, RootID extends string> = {
    [K in keyof Adj as K extends CollectReachable<Adj, [RootID]> ? K : never]: Adj[K];
};

// @public
export function liveAdj(adj: Record<string, RuntimeEntry>, rootId: string): Record<string, RuntimeEntry>;

// @public
export function lower<A>(a: A): CExpr<string, "str/lower", [A]>;

// @public
export function lt<A, B>(a: A, b: B): CExpr<boolean, "lt", [A, B]>;

// @public
export function makeCExpr<O, Kind extends string, Args extends readonly unknown[]>(kind: Kind, args: [...Args]): CExpr<O, Kind, Args>;

// @public
export function makeNExpr<O, RootId extends string, Adj, Ctr extends string>(rootId: RootId, adj: Record<string, RuntimeEntry>, counter: Ctr): NExpr<O, RootId, Adj, Ctr>;

// @public
export type MapAdj<Adj, P, NewEntry extends NodeEntry<string, string[], any>> = {
    [K in keyof Adj]: K extends string ? EvalPred<P, Adj[K], K, Adj> extends true ? NewEntry : Adj[K] : Adj[K];
};

// @public
export type MapOut<O, Adj, RootID extends string, P, NewEntry extends NodeEntry<string, string[], any>> = RootID extends keyof Adj ? EvalPred<P, Adj[RootID & keyof Adj], RootID, Adj> extends true ? NewEntry extends NodeEntry<any, any, infer NewO> ? NewO : O : O : O;

// @public
export interface MapTypeError<_Msg extends string = string> {
    // (undocumented)
    readonly __brand: unique symbol;
    // (undocumented)
    readonly __mapTypeError: _Msg;
}

// Warning: (ae-forgotten-export) The symbol "MapTypeSafe" needs to be exported by the entry point index.d.ts
//
// @public
export function mapWhere<O, R extends string, Adj, C extends string, P extends PredBase, NewEntry extends NodeEntry<string, string[], any>>(expr: NExpr<O, R, Adj, C> | DirtyExpr<O, R, Adj, C>, pred: P, fn: (entry: MatchingEntries<Adj, P>) => NewEntry): MapTypeSafe<Adj, P, NewEntry> extends true ? DirtyExpr<MapOut<O, Adj, R, P, NewEntry>, R, MapAdj<Adj, P, NewEntry>, C> : MapTypeError<"callback output type does not match matched node output type">;

// @public
export type MatchingEntries<Adj, P> = {
    [K in keyof Adj]: K extends string ? EvalPred<P, Adj[K], K, Adj> extends true ? Adj[K] : never : never;
}[keyof Adj];

// @public
export function max<A, B>(a: A, b: B): CExpr<number, "num/max", [A, B]>;

// @public
export function min<A, B>(a: A, b: B): CExpr<number, "num/min", [A, B]>;

// @public
export function mod<A, B>(a: A, b: B): CExpr<number, "num/mod", [A, B]>;

// @public
export function mul<A, B>(a: A, b: B): CExpr<number, "num/mul", [A, B]>;

// @public
export function mvfm(...pluginInputs: (Plugin_2 | readonly Plugin_2[])[]): {
    (schemaOrFn: any, maybeFn?: any): Program;
    plugins: Plugin_2<string, any, any, any, any>[];
};

// @public
export function mvfmU<const P extends readonly Plugin_2[]>(...plugins: P): DollarSign<P>;

// Warning: (ae-forgotten-export) The symbol "TargetOut" needs to be exported by the entry point index.d.ts
//
// @public
function name_2<O, R extends string, Adj, C extends string, N extends string, T extends string>(expr: NExpr<O, R, Adj, C>, n: N, targetId: T): NExpr<O, R, Adj & Record<`@${N}`, NameAlias<N, T, TargetOut<Adj, T>>>, C>;
export { name_2 as name }

// @public
export type NameAlias<_Name extends string, TargetID extends string, Out> = NodeEntry<"@alias", [
TargetID
], Out>;

// @public
export interface NamePred<N extends string> extends PredBase {
    // (undocumented)
    readonly name: N;
    // (undocumented)
    readonly _tag: "name";
}

// @public
export function neg<A>(a: A): CExpr<number, "num/neg", [A]>;

// @public
export type NeverGuard<T, Then> = [T] extends [never] ? never : Then;

// @public
export interface NExpr<O, RootId extends string, Adj, Ctr extends string> {
    // (undocumented)
    readonly [nexprBrand]: {
        readonly o: O;
        readonly rootId: RootId;
        readonly adj: Adj;
        readonly ctr: Ctr;
    };
    // (undocumented)
    readonly __adj: Record<string, RuntimeEntry>;
    // (undocumented)
    readonly __counter: string;
    // (undocumented)
    readonly __id: string;
}

// @public
export type NodeEntry<Kind extends string, ChildIDs extends string[], Out> = {
    readonly kind: Kind;
    readonly children: ChildIDs;
    readonly out: Out;
};

// @public @deprecated (undocumented)
export interface NodeTypeMap {
}

// @public
export function not<P extends PredBase>(pred: P): NotPred<P>;

// @public
export interface NotPred<P extends PredBase> extends PredBase {
    // (undocumented)
    readonly pred: P;
    // (undocumented)
    readonly _tag: "not";
}

// @public
export function numLit<V extends number>(v: V): V;

// @public
export const numPlugin: {
    readonly name: "num";
    readonly ctors: {
        readonly add: typeof add;
        readonly mul: typeof mul;
        readonly sub: typeof sub;
        readonly div: typeof div;
        readonly mod: typeof mod;
        readonly min: typeof min;
        readonly max: typeof max;
        readonly neg: typeof neg;
        readonly abs: typeof abs;
        readonly floor: typeof floor;
        readonly ceil: typeof ceil;
        readonly round: typeof round;
        readonly numLit: typeof numLit;
    };
    readonly kinds: {
        readonly "num/literal": KindSpec<[], number>;
        readonly "num/add": KindSpec<[number, number], number>;
        readonly "num/mul": KindSpec<[number, number], number>;
        readonly "num/sub": KindSpec<[number, number], number>;
        readonly "num/div": KindSpec<[number, number], number>;
        readonly "num/mod": KindSpec<[number, number], number>;
        readonly "num/neg": KindSpec<[number], number>;
        readonly "num/abs": KindSpec<[number], number>;
        readonly "num/floor": KindSpec<[number], number>;
        readonly "num/ceil": KindSpec<[number], number>;
        readonly "num/round": KindSpec<[number], number>;
        readonly "num/min": KindSpec<[number, number], number>;
        readonly "num/max": KindSpec<[number, number], number>;
        readonly "num/show": KindSpec<[number], string>;
        readonly "num/compare": KindSpec<[number, number], number>;
        readonly "num/eq": KindSpec<[number, number], boolean>;
        readonly "num/neq": KindSpec<[number, number], boolean>;
        readonly "num/zero": KindSpec<[], number>;
        readonly "num/one": KindSpec<[], number>;
        readonly "num/top": KindSpec<[], number>;
        readonly "num/bottom": KindSpec<[], number>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
            number: "num/eq";
        }>;
        readonly neq: TraitDef<boolean, {
            number: "num/neq";
        }>;
        readonly show: TraitDef<string, {
            number: "num/show";
        }>;
    };
    readonly lifts: {
        readonly number: "num/literal";
    };
    readonly nodeKinds: readonly ["num/literal", "num/add", "num/mul", "num/sub", "num/div", "num/mod", "num/neg", "num/abs", "num/floor", "num/ceil", "num/round", "num/min", "num/max", "num/show", "num/compare", "num/eq", "num/neq", "num/zero", "num/one", "num/top", "num/bottom"];
    readonly defaultInterpreter: () => Interpreter;
};

// @public @deprecated (undocumented)
export const numPluginU: {
    readonly name: "num";
    readonly ctors: {
        readonly add: add;
        readonly mul: mul;
        readonly sub: sub;
        readonly div: div;
        readonly mod: mod;
        readonly min: min;
        readonly max: max;
        readonly neg: neg;
        readonly abs: abs;
        readonly floor: floor;
        readonly ceil: ceil;
        readonly round: round;
        readonly numLit: numLit;
    };
    readonly kinds: {
        readonly "num/literal": KindSpec<[], number>;
        readonly "num/add": KindSpec<[number, number], number>;
        readonly "num/mul": KindSpec<[number, number], number>;
        readonly "num/sub": KindSpec<[number, number], number>;
        readonly "num/div": KindSpec<[number, number], number>;
        readonly "num/mod": KindSpec<[number, number], number>;
        readonly "num/neg": KindSpec<[number], number>;
        readonly "num/abs": KindSpec<[number], number>;
        readonly "num/floor": KindSpec<[number], number>;
        readonly "num/ceil": KindSpec<[number], number>;
        readonly "num/round": KindSpec<[number], number>;
        readonly "num/min": KindSpec<[number, number], number>;
        readonly "num/max": KindSpec<[number, number], number>;
        readonly "num/show": KindSpec<[number], string>;
        readonly "num/compare": KindSpec<[number, number], number>;
        readonly "num/eq": KindSpec<[number, number], boolean>;
        readonly "num/neq": KindSpec<[number, number], boolean>;
        readonly "num/zero": KindSpec<[], number>;
        readonly "num/one": KindSpec<[], number>;
        readonly "num/top": KindSpec<[], number>;
        readonly "num/bottom": KindSpec<[], number>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
        number: "num/eq";
        }>;
        readonly neq: TraitDef<boolean, {
        number: "num/neq";
        }>;
        readonly show: TraitDef<string, {
        number: "num/show";
        }>;
    };
    readonly lifts: {
        readonly number: "num/literal";
    };
    readonly nodeKinds: readonly ["num/literal", "num/add", "num/mul", "num/sub", "num/div", "num/mod", "num/neg", "num/abs", "num/floor", "num/ceil", "num/round", "num/min", "num/max", "num/show", "num/compare", "num/eq", "num/neq", "num/zero", "num/one", "num/top", "num/bottom"];
    readonly defaultInterpreter: () => Interpreter;
};

// @public
export function or<A extends PredBase, B extends PredBase>(left: A, right: B): OrPred<A, B>;

// @public
const ordPlugin: {
    readonly name: "ord";
    readonly ctors: {
        readonly lt: typeof lt;
    };
    readonly kinds: {
        readonly "num/lt": KindSpec<[number, number], boolean>;
        readonly "num/gt": KindSpec<[number, number], boolean>;
        readonly "num/gte": KindSpec<[number, number], boolean>;
        readonly "num/lte": KindSpec<[number, number], boolean>;
        readonly "str/lt": KindSpec<[string, string], boolean>;
        readonly "str/gt": KindSpec<[string, string], boolean>;
        readonly "str/gte": KindSpec<[string, string], boolean>;
        readonly "str/lte": KindSpec<[string, string], boolean>;
        readonly "str/compare": KindSpec<[string, string], number>;
        readonly "num/compare": KindSpec<[number, number], number>;
    };
    readonly traits: {
        readonly lt: TraitDef<boolean, {
            number: "num/lt";
            string: "str/lt";
        }>;
        readonly gt: TraitDef<boolean, {
            number: "num/gt";
            string: "str/gt";
        }>;
        readonly gte: TraitDef<boolean, {
            number: "num/gte";
            string: "str/gte";
        }>;
        readonly lte: TraitDef<boolean, {
            number: "num/lte";
            string: "str/lte";
        }>;
        readonly compare: TraitDef<number, {
            number: "num/compare";
            string: "str/compare";
        }>;
    };
    readonly lifts: {};
    readonly nodeKinds: readonly ["num/lt", "num/gt", "num/gte", "num/lte", "str/lt", "str/gt", "str/gte", "str/lte", "str/compare", "num/compare"];
    readonly defaultInterpreter: () => Interpreter;
};
export { ordPlugin as _ordPluginDef }
export { ordPlugin }

// @public
export interface OrPred<A extends PredBase, B extends PredBase> extends PredBase {
    // (undocumented)
    readonly left: A;
    // (undocumented)
    readonly right: B;
    // (undocumented)
    readonly _tag: "or";
}

// @public
export type OutOf<E> = E extends NExpr<infer O, any, any, any> ? O : never;

// @public
export function pipe<A extends NExpr<any, any, any, any>, B>(expr: A, f1: (a: A) => B): B;

// @public
export function pipe<A extends NExpr<any, any, any, any>, B, C>(expr: A, f1: (a: A) => B, f2: (b: B) => C): C;

// @public
export function pipe<A extends NExpr<any, any, any, any>, B, C, D>(expr: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D): D;

// @public
export function pipe<A extends NExpr<any, any, any, any>, B, C, D, E>(expr: A, f1: (a: A) => B, f2: (b: B) => C, f3: (c: C) => D, f4: (d: D) => E): E;

// @public
interface Plugin_2<Name extends string = string, Ctors extends Record<string, (...args: any[]) => any> = any, Kinds extends Record<string, KindSpec<any, any>> = any, Traits extends Record<string, TraitDef<any, any>> = any, Lifts extends Record<string, string> = any> {
    // (undocumented)
    readonly ctors: Ctors;
    // (undocumented)
    readonly defaultInterpreter?: () => Interpreter;
    // (undocumented)
    readonly kinds: Kinds;
    // (undocumented)
    readonly lifts: Lifts;
    // (undocumented)
    readonly name: Name;
    // (undocumented)
    readonly nodeKinds: readonly string[];
    // (undocumented)
    readonly shapes?: Record<string, unknown>;
    // (undocumented)
    readonly traits: Traits;
}
export { Plugin_2 as Plugin }

// @public @deprecated (undocumented)
export interface PluginContext {
    // (undocumented)
    emit(node: unknown): void;
    // (undocumented)
    expr<T>(opts: Record<string, unknown>): Expr<T>;
    // (undocumented)
    inputSchema: unknown;
    // (undocumented)
    isExpr(value: unknown): value is ExprBase<unknown>;
    // (undocumented)
    lift<T>(value: T | Expr<T>): ExprBase<T>;
    // (undocumented)
    plugins: unknown[];
    // (undocumented)
    _registry: Map<number, unknown>;
    // (undocumented)
    statements: unknown[];
}

// @public
export interface PluginDef {
    // (undocumented)
    defaultInterpreter?: () => Interpreter;
    // (undocumented)
    name: string;
    // (undocumented)
    nodeKinds: readonly string[];
}

// @public
export interface PredBase {
    // (undocumented)
    test(entry: RuntimeEntry, id: string, adj: Record<string, RuntimeEntry>): boolean;
}

// @public
export const prelude: readonly Plugin_2[];

// @public
export type PreserveAliases<Adj> = {
    [K in keyof Adj as K extends `@${string}` ? K : never]: Adj[K];
};

// @public
export interface Program {
    // (undocumented)
    readonly __inputSchema?: Record<string, string>;
    // (undocumented)
    readonly __nexpr: NExpr<any, any, any, any>;
    // (undocumented)
    readonly __plugins: readonly Plugin_2[];
}

// @public
export function recurseScoped(childId: string, bindings: Array<{
    paramId: string;
    value: unknown;
}>): RecurseScopedEffect;

// @public
export interface RecurseScopedEffect {
    // (undocumented)
    readonly bindings: ScopedBinding[];
    // (undocumented)
    readonly childId: string;
    // (undocumented)
    readonly type: "recurse_scoped";
}

// @public
export type RegistryEntry = KindSpec<any, any> | TraitKindSpec<any, any>;

// Warning: (ae-forgotten-export) The symbol "MergeKinds" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TraitEntries" needs to be exported by the entry point index.d.ts
//
// @public
export type RegistryOf<P extends readonly Plugin_2[]> = MergeKinds<P> & TraitEntries<P>;

// @public
export function remapChildren(children: unknown, oldId: string, newId: string): unknown;

// @public
export function removeEntry<O, R extends string, Adj, C extends string, Id extends string>(d: DirtyExpr<O, R, Adj, C>, id: Id): DirtyExpr<O, R, {
    [K in keyof Adj as K extends Id ? never : K]: Adj[K];
}, C>;

// @public
export function replace<A, B, C>(s: A, search: B, replacement: C): CExpr<string, "str/replace", [A, B, C]>;

// Warning: (ae-forgotten-export) The symbol "ReplaceKind" needs to be exported by the entry point index.d.ts
//
// @public
export function replaceWhere<O, R extends string, Adj, C extends string, P extends PredBase, NewKind extends string>(expr: NExpr<O, R, Adj, C> | DirtyExpr<O, R, Adj, C>, pred: P, newKind: NewKind): DirtyExpr<MapOut<O, Adj, R, P, ReplaceKind<MatchingEntries<Adj, P>, NewKind>>, R, MapAdj<Adj, P, ReplaceKind<MatchingEntries<Adj, P>, NewKind>>, C>;

// Warning: (ae-forgotten-export) The symbol "RewireList" needs to be exported by the entry point index.d.ts
//
// @public
export type RewireAdj<Adj, Old extends string, New extends string> = {
    [K in keyof Adj]: Adj[K] extends NodeEntry<infer Kind extends string, infer C extends string[], infer O> ? NodeEntry<Kind, RewireList<C, Old, New>, O> : Adj[K];
};

// Warning: (ae-forgotten-export) The symbol "RewireTypeSafe" needs to be exported by the entry point index.d.ts
//
// @public
export function rewireChildren<O, R extends string, Adj, C extends string, Old extends string, New extends string>(d: DirtyExpr<O, R, Adj, C>, oldRef: Old, newRef: New): RewireTypeSafe<Adj, Old, New> extends true ? DirtyExpr<O, R, RewireAdj<Adj, Old, New>, C> : RewireTypeError<"new ref output type does not match old ref output type">;

// @public
export type RewireParents<Adj, TargetID extends string, WrapperID extends string> = RewireAdj<Adj, TargetID, WrapperID>;

// @public
export interface RewireTypeError<_Msg extends string = string> {
    // (undocumented)
    readonly __brand: unique symbol;
    // (undocumented)
    readonly __rewireTypeError: _Msg;
}

// @public
export function round<A>(a: A): CExpr<number, "num/round", [A]>;

// @public
export interface RuntimeEntry {
    // (undocumented)
    children: string[];
    // (undocumented)
    kind: string;
    // (undocumented)
    out: unknown;
}

// @public
export interface ScopedBinding {
    // (undocumented)
    readonly paramId: string;
    // (undocumented)
    readonly value: unknown;
}

// @public
export type SelectKeys<Adj, P> = {
    [K in keyof Adj]: K extends string ? EvalPred<P, Adj[K], K, Adj> extends true ? K : never : never;
}[keyof Adj];

// @public
export function selectWhere<O, R extends string, Adj, C extends string, P extends PredBase>(expr: NExpr<O, R, Adj, C>, pred: P): Set<string & SelectKeys<Adj, P>>;

// @public
export function setRoot<O, R extends string, Adj, C extends string, NewRoot extends string>(d: DirtyExpr<O, R, Adj, C>, newRootId: NewRoot): DirtyExpr<O, NewRoot, Adj, C>;

// @public
export function slice<A, B, C>(s: A, start: B, end?: C): CExpr<string, "str/slice", [A, B, ...unknown[]]>;

// @public
export type SNodeEntry<Kind extends string = string, Ch = unknown, O = unknown> = {
    readonly kind: Kind;
    readonly children: Ch;
    readonly out: O;
};

// Warning: (ae-forgotten-export) The symbol "SpliceAt" needs to be exported by the entry point index.d.ts
//
// @public
export type SpliceAdj<Adj, Matched extends string, I extends number = 0> = {
    [K in keyof Adj as K extends Matched ? never : K]: Adj[K] extends NodeEntry<infer Kind extends string, infer Ch extends string[], infer O> ? NodeEntry<Kind, SpliceAt<Ch, Adj, Matched, I>, O> : Adj[K];
};

// @public
export interface SpliceTypeError<_Msg extends string = string> {
    // (undocumented)
    readonly __brand: unique symbol;
    // (undocumented)
    readonly __spliceTypeError: _Msg;
}

// Warning: (ae-forgotten-export) The symbol "SpliceTypeSafe" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SpliceRoot" needs to be exported by the entry point index.d.ts
//
// @public
export function spliceWhere<O, R extends string, Adj, C extends string, P extends PredBase, I extends number = 0>(expr: NExpr<O, R, Adj, C>, pred: P, childIndex?: I): SpliceTypeSafe<Adj, SelectKeys<Adj, P>, I> extends true ? NExpr<O, SpliceRoot<R, Adj, SelectKeys<Adj, P>, I>, SpliceAdj<Adj, SelectKeys<Adj, P>, I>, C> : SpliceTypeError<"replacement child output type does not match spliced node output type">;

// @public
export function split<A, B>(s: A, sep: B): CExpr<string[], "str/split", [A, B]>;

// @public
export const st: Plugin_2;

// @public
export function startsWith<A, B>(s: A, prefix: B): CExpr<boolean, "str/startsWith", [A, B]>;

// @public
export const stdPlugins: readonly [{
    readonly name: "num";
    readonly ctors: {
        readonly add: typeof add;
        readonly mul: typeof mul;
        readonly sub: typeof sub;
        readonly div: typeof div;
        readonly mod: typeof mod;
        readonly min: typeof min;
        readonly max: typeof max;
        readonly neg: typeof neg;
        readonly abs: typeof abs;
        readonly floor: typeof floor;
        readonly ceil: typeof ceil;
        readonly round: typeof round;
        readonly numLit: typeof numLit;
    };
    readonly kinds: {
        readonly "num/literal": KindSpec<[], number>;
        readonly "num/add": KindSpec<[number, number], number>;
        readonly "num/mul": KindSpec<[number, number], number>;
        readonly "num/sub": KindSpec<[number, number], number>;
        readonly "num/div": KindSpec<[number, number], number>;
        readonly "num/mod": KindSpec<[number, number], number>;
        readonly "num/neg": KindSpec<[number], number>;
        readonly "num/abs": KindSpec<[number], number>;
        readonly "num/floor": KindSpec<[number], number>;
        readonly "num/ceil": KindSpec<[number], number>;
        readonly "num/round": KindSpec<[number], number>;
        readonly "num/min": KindSpec<[number, number], number>;
        readonly "num/max": KindSpec<[number, number], number>;
        readonly "num/show": KindSpec<[number], string>;
        readonly "num/compare": KindSpec<[number, number], number>;
        readonly "num/eq": KindSpec<[number, number], boolean>;
        readonly "num/neq": KindSpec<[number, number], boolean>;
        readonly "num/zero": KindSpec<[], number>;
        readonly "num/one": KindSpec<[], number>;
        readonly "num/top": KindSpec<[], number>;
        readonly "num/bottom": KindSpec<[], number>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
            number: "num/eq";
        }>;
        readonly neq: TraitDef<boolean, {
            number: "num/neq";
        }>;
        readonly show: TraitDef<string, {
            number: "num/show";
        }>;
    };
    readonly lifts: {
        readonly number: "num/literal";
    };
    readonly nodeKinds: readonly ["num/literal", "num/add", "num/mul", "num/sub", "num/div", "num/mod", "num/neg", "num/abs", "num/floor", "num/ceil", "num/round", "num/min", "num/max", "num/show", "num/compare", "num/eq", "num/neq", "num/zero", "num/one", "num/top", "num/bottom"];
    readonly defaultInterpreter: () => Interpreter;
}, {
    readonly name: "str";
    readonly ctors: {
        readonly strLit: strLit;
        readonly str: str;
        readonly concat: concat;
        readonly upper: upper;
        readonly lower: lower;
        readonly trim: trim;
        readonly slice: slice;
        readonly includes: includes;
        readonly startsWith: startsWith;
        readonly endsWith: endsWith;
        readonly split: split;
        readonly join: join;
        readonly replace: replace;
        readonly len: len;
        readonly strShow: strShow;
        readonly strAppend: strAppend;
    };
    readonly kinds: {
        readonly "str/literal": KindSpec<[], string>;
        readonly "str/concat": KindSpec<string[], string>;
        readonly "str/upper": KindSpec<[string], string>;
        readonly "str/lower": KindSpec<[string], string>;
        readonly "str/trim": KindSpec<[string], string>;
        readonly "str/slice": KindSpec<[string, number, number], string>;
        readonly "str/includes": KindSpec<[string, string], boolean>;
        readonly "str/startsWith": KindSpec<[string, string], boolean>;
        readonly "str/endsWith": KindSpec<[string, string], boolean>;
        readonly "str/split": KindSpec<[string, string], string[]>;
        readonly "str/join": KindSpec<[string[], string], string>;
        readonly "str/replace": KindSpec<[string, string, string], string>;
        readonly "str/len": KindSpec<[string], number>;
        readonly "str/show": KindSpec<[string], string>;
        readonly "str/append": KindSpec<[string, string], string>;
        readonly "str/mempty": KindSpec<[], string>;
        readonly "str/eq": KindSpec<[string, string], boolean>;
        readonly "str/neq": KindSpec<[string, string], boolean>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
            string: "str/eq";
        }>;
        readonly neq: TraitDef<boolean, {
            string: "str/neq";
        }>;
        readonly show: TraitDef<string, {
            string: "str/show";
        }>;
        readonly append: TraitDef<string, {
            string: "str/append";
        }>;
    };
    readonly lifts: {
        readonly string: "str/literal";
    };
    readonly nodeKinds: readonly ["str/literal", "str/concat", "str/upper", "str/lower", "str/trim", "str/slice", "str/includes", "str/startsWith", "str/endsWith", "str/split", "str/join", "str/replace", "str/len", "str/show", "str/append", "str/mempty", "str/eq", "str/neq"];
    readonly defaultInterpreter: () => Interpreter;
}, {
    readonly name: "bool";
    readonly ctors: {
        readonly boolLit: boolLit;
        readonly and: boolAnd;
        readonly or: boolOr;
        readonly not: boolNot;
    };
    readonly kinds: {
        readonly "bool/literal": KindSpec<[], boolean>;
        readonly "bool/eq": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/neq": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/and": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/or": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/not": KindSpec<[boolean], boolean>;
        readonly "bool/implies": KindSpec<[boolean, boolean], boolean>;
        readonly "bool/show": KindSpec<[boolean], string>;
        readonly "bool/tt": KindSpec<[], boolean>;
        readonly "bool/ff": KindSpec<[], boolean>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
            boolean: "bool/eq";
        }>;
        readonly neq: TraitDef<boolean, {
            boolean: "bool/neq";
        }>;
        readonly show: TraitDef<string, {
            boolean: "bool/show";
        }>;
    };
    readonly lifts: {
        readonly boolean: "bool/literal";
    };
    readonly nodeKinds: readonly ["bool/literal", "bool/eq", "bool/neq", "bool/and", "bool/or", "bool/not", "bool/implies", "bool/show", "bool/tt", "bool/ff"];
    readonly defaultInterpreter: () => Interpreter;
}];

// @public
export type StdRegistry = {
    "num/literal": KindSpec<[], number>;
    "num/add": KindSpec<[number, number], number>;
    "num/mul": KindSpec<[number, number], number>;
    "num/sub": KindSpec<[number, number], number>;
    "str/literal": KindSpec<[], string>;
    "bool/literal": KindSpec<[], boolean>;
    "num/eq": KindSpec<[number, number], boolean>;
    "str/eq": KindSpec<[string, string], boolean>;
    "bool/eq": KindSpec<[boolean, boolean], boolean>;
    eq: TraitKindSpec<boolean, {
        number: "num/eq";
        string: "str/eq";
        boolean: "bool/eq";
    }>;
};

// @public
export function str(strings: TemplateStringsArray, ...exprs: unknown[]): CExpr<string, "str/concat", unknown[]>;

// @public
export function strAppend<A, B>(a: A, b: B): CExpr<string, "str/append", [A, B]>;

// @public
export function strLit<V extends string>(v: V): V;

// @public
const strPlugin: {
    readonly name: "str";
    readonly ctors: {
        readonly strLit: typeof strLit;
        readonly str: typeof str;
        readonly concat: typeof concat;
        readonly upper: typeof upper;
        readonly lower: typeof lower;
        readonly trim: typeof trim;
        readonly slice: typeof slice;
        readonly includes: typeof includes;
        readonly startsWith: typeof startsWith;
        readonly endsWith: typeof endsWith;
        readonly split: typeof split;
        readonly join: typeof join;
        readonly replace: typeof replace;
        readonly len: typeof len;
        readonly strShow: typeof strShow;
        readonly strAppend: typeof strAppend;
    };
    readonly kinds: {
        readonly "str/literal": KindSpec<[], string>;
        readonly "str/concat": KindSpec<string[], string>;
        readonly "str/upper": KindSpec<[string], string>;
        readonly "str/lower": KindSpec<[string], string>;
        readonly "str/trim": KindSpec<[string], string>;
        readonly "str/slice": KindSpec<[string, number, number], string>;
        readonly "str/includes": KindSpec<[string, string], boolean>;
        readonly "str/startsWith": KindSpec<[string, string], boolean>;
        readonly "str/endsWith": KindSpec<[string, string], boolean>;
        readonly "str/split": KindSpec<[string, string], string[]>;
        readonly "str/join": KindSpec<[string[], string], string>;
        readonly "str/replace": KindSpec<[string, string, string], string>;
        readonly "str/len": KindSpec<[string], number>;
        readonly "str/show": KindSpec<[string], string>;
        readonly "str/append": KindSpec<[string, string], string>;
        readonly "str/mempty": KindSpec<[], string>;
        readonly "str/eq": KindSpec<[string, string], boolean>;
        readonly "str/neq": KindSpec<[string, string], boolean>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
            string: "str/eq";
        }>;
        readonly neq: TraitDef<boolean, {
            string: "str/neq";
        }>;
        readonly show: TraitDef<string, {
            string: "str/show";
        }>;
        readonly append: TraitDef<string, {
            string: "str/append";
        }>;
    };
    readonly lifts: {
        readonly string: "str/literal";
    };
    readonly nodeKinds: readonly ["str/literal", "str/concat", "str/upper", "str/lower", "str/trim", "str/slice", "str/includes", "str/startsWith", "str/endsWith", "str/split", "str/join", "str/replace", "str/len", "str/show", "str/append", "str/mempty", "str/eq", "str/neq"];
    readonly defaultInterpreter: () => Interpreter;
};
export { strPlugin as _strPluginDef }
export { strPlugin }

// @public @deprecated (undocumented)
export const strPluginU: {
    readonly name: "str";
    readonly ctors: {
        readonly strLit: strLit;
        readonly str: str;
        readonly concat: concat;
        readonly upper: upper;
        readonly lower: lower;
        readonly trim: trim;
        readonly slice: slice;
        readonly includes: includes;
        readonly startsWith: startsWith;
        readonly endsWith: endsWith;
        readonly split: split;
        readonly join: join;
        readonly replace: replace;
        readonly len: len;
        readonly strShow: strShow;
        readonly strAppend: strAppend;
    };
    readonly kinds: {
        readonly "str/literal": KindSpec<[], string>;
        readonly "str/concat": KindSpec<string[], string>;
        readonly "str/upper": KindSpec<[string], string>;
        readonly "str/lower": KindSpec<[string], string>;
        readonly "str/trim": KindSpec<[string], string>;
        readonly "str/slice": KindSpec<[string, number, number], string>;
        readonly "str/includes": KindSpec<[string, string], boolean>;
        readonly "str/startsWith": KindSpec<[string, string], boolean>;
        readonly "str/endsWith": KindSpec<[string, string], boolean>;
        readonly "str/split": KindSpec<[string, string], string[]>;
        readonly "str/join": KindSpec<[string[], string], string>;
        readonly "str/replace": KindSpec<[string, string, string], string>;
        readonly "str/len": KindSpec<[string], number>;
        readonly "str/show": KindSpec<[string], string>;
        readonly "str/append": KindSpec<[string, string], string>;
        readonly "str/mempty": KindSpec<[], string>;
        readonly "str/eq": KindSpec<[string, string], boolean>;
        readonly "str/neq": KindSpec<[string, string], boolean>;
    };
    readonly traits: {
        readonly eq: TraitDef<boolean, {
        string: "str/eq";
        }>;
        readonly neq: TraitDef<boolean, {
        string: "str/neq";
        }>;
        readonly show: TraitDef<string, {
        string: "str/show";
        }>;
        readonly append: TraitDef<string, {
        string: "str/append";
        }>;
    };
    readonly lifts: {
        readonly string: "str/literal";
    };
    readonly nodeKinds: readonly ["str/literal", "str/concat", "str/upper", "str/lower", "str/trim", "str/slice", "str/includes", "str/startsWith", "str/endsWith", "str/split", "str/join", "str/replace", "str/len", "str/show", "str/append", "str/mempty", "str/eq", "str/neq"];
    readonly defaultInterpreter: () => Interpreter;
};

// @public
export function strShow<A>(s: A): CExpr<string, "str/show", [A]>;

// @public
export function sub<A, B>(a: A, b: B): CExpr<number, "num/sub", [A, B]>;

// Warning: (ae-forgotten-export) The symbol "SwapTypeSafe" needs to be exported by the entry point index.d.ts
//
// @public
export function swapEntry<O, R extends string, Adj, C extends string, Id extends string, E extends NodeEntry<string, string[], any>>(d: DirtyExpr<O, R, Adj, C>, id: Id, entry: E): SwapTypeSafe<Adj, Id, E> extends true ? DirtyExpr<O, R, {
    [K in keyof Adj as K extends Id ? never : K]: Adj[K];
} & Record<Id, E>, C> : SwapTypeError<"new entry output type does not match existing entry output type">;

// @public
export interface SwapTypeError<_Msg extends string = string> {
    // (undocumented)
    readonly __brand: unique symbol;
    // (undocumented)
    readonly __swapTypeError: _Msg;
}

// @public
export const TRAIT_MAP: Record<string, Record<string, string>>;

// @public
export interface TraitDef<O, Mapping extends Record<string, string>> {
    // (undocumented)
    readonly mapping: Mapping;
    // (undocumented)
    readonly output: O;
}

// @public
export interface TraitKindSpec<O, Mapping extends Record<string, string>> {
    // (undocumented)
    readonly mapping: Mapping;
    // (undocumented)
    readonly output: O;
    // (undocumented)
    readonly trait: true;
}

// @public
export function trim<A>(a: A): CExpr<string, "str/trim", [A]>;

// @public @deprecated (undocumented)
export interface TypedNode<T = unknown> {
    // (undocumented)
    readonly [key: string]: unknown;
    // (undocumented)
    readonly __T?: T;
    // (undocumented)
    readonly args?: TypedNode[];
    // (undocumented)
    readonly kind: string;
}

// @public
export type TypeKey<T> = T extends number ? "number" : T extends string ? "string" : T extends boolean ? "boolean" : never;

// Warning: (ae-forgotten-export) The symbol "_LastOf" needs to be exported by the entry point index.d.ts
//
// @public
export type UnionToTuple<U, Last = _LastOf<U>> = [U] extends [never] ? [] : [...UnionToTuple<Exclude<U, Last>>, Last];

// @public
export function upper<A>(a: A): CExpr<string, "str/upper", [A]>;

// @public
export const VOLATILE_KINDS: Set<string>;

// Warning: (ae-forgotten-export) The symbol "WrapRoot" needs to be exported by the entry point index.d.ts
//
// @public
export function wrapByName<O, R extends string, Adj, C extends string, TargetID extends string, WrapperKind extends string>(expr: NExpr<O, R, Adj, C> | DirtyExpr<O, R, Adj, C>, targetId: TargetID, wrapperKind: WrapperKind): DirtyExpr<O, WrapRoot<R, TargetID, C>, WrapOneResult<Adj, TargetID, WrapperKind, C>, Increment<C>>;

// Warning: (ae-forgotten-export) The symbol "TargetOut_2" needs to be exported by the entry point index.d.ts
//
// @public
export type WrapOneResult<Adj, TargetID extends string, WrapperKind extends string, WrapperID extends string> = RewireParents<Adj, TargetID, WrapperID> & Record<WrapperID, NodeEntry<WrapperKind, [TargetID], TargetOut_2<Adj, TargetID>>>;

// (No @packageDocumentation comment for this package)

```
