## API Report File for "@mvfm/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function adaptLegacy(fragment: LegacyInterpreterFragment): InterpreterFragment;

// @public
export function array(of: SchemaType): ArraySchema;

// @public
export interface ArraySchema {
    // (undocumented)
    readonly __tag: "array";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export interface ASTNode {
    // (undocumented)
    __id?: number;
    // (undocumented)
    [key: string]: unknown;
    // (undocumented)
    kind: string;
}

// @public
export const boolean: PluginDefinition<BooleanMethods, {
    eq: boolean;
    show: boolean;
    heytingAlgebra: boolean;
    bounded: boolean;
}>;

// @public
export const booleanInterpreter: InterpreterFragment;

// @public
export type BooleanMethods = {};

// Warning: (ae-incompatible-release-tags) The symbol "bounded" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const bounded: PluginDefinition<TypeclassSlot<"bounded">>;

// @public
export interface BoundedFor<_T> {
}

// @public
export function composeInterpreters(fragments: InterpreterFragment[]): RecurseFn;

// @public
export const control: PluginDefinition<ControlMethods>;

// @public
export interface ControlMethods {
    each<T>(collection: Expr<T[]>, body: (item: Expr<T>) => void): void;
    while(condition: Expr<boolean>): {
        body: (...statements: unknown[]) => void;
    };
}

// @public
export const coreInterpreter: InterpreterFragment;

// Warning: (ae-incompatible-release-tags) The symbol "eq" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const eq: PluginDefinition<TypeclassSlot<"eq">>;

// @public
export interface EqFor<T> {
    eq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    neq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const eqInterpreter: InterpreterFragment;

// @public
export const error: PluginDefinition<ErrorMethods>;

// @public
export const errorInterpreter: InterpreterFragment;

// @public
export interface ErrorMethods {
    attempt<T>(expr: Expr<T>): Expr<{
        ok: T | null;
        err: any | null;
    }>;
    fail(error: Expr<any> | any): Expr<never>;
    guard(condition: Expr<boolean>, error: Expr<any> | any): Expr<void>;
    orElse<T>(expr: Expr<T>, fallback: Expr<T> | T): Expr<T>;
    settle(...exprs: Expr<any>[]): Expr<{
        fulfilled: any[];
        rejected: any[];
    }>;
    // Warning: (ae-forgotten-export) The symbol "TryBuilder" needs to be exported by the entry point index.d.ts
    try<T>(expr: Expr<T>): TryBuilder<T>;
}

// Warning: (ae-forgotten-export) The symbol "ExprBase" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExprFields" needs to be exported by the entry point index.d.ts
//
// @public
export type Expr<T> = ExprBase<T> & ExprFields<T>;

// @public
export const fiber: PluginDefinition<FiberMethods>;

// @public
export const fiberInterpreter: InterpreterFragment;

// @public
export interface FiberMethods {
    // Warning: (ae-forgotten-export) The symbol "ParFn" needs to be exported by the entry point index.d.ts
    par: ParFn;
    race(...exprs: Expr<any>[]): Expr<any>;
    retry(expr: Expr<any>, opts: {
        attempts: number;
        delay?: number;
    }): Expr<any>;
    seq(...exprs: (Expr<any> | any)[]): Expr<any>;
    timeout(expr: Expr<any>, ms: number | Expr<number>, fallback: Expr<any> | any): Expr<any>;
}

// @public
export function foldAST(fragments: InterpreterFragment[], handlers: Record<string, (effect: StepEffect) => Promise<unknown>>): RecurseFn;

// @public @deprecated
export type GeneratorInterpreterFragment = InterpreterFragment;

// Warning: (ae-incompatible-release-tags) The symbol "heytingAlgebra" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const heytingAlgebra: PluginDefinition<TypeclassSlot<"heytingAlgebra">>;

// @public
export interface HeytingAlgebraFor<T> {
    and(a: Expr<T>, b: Expr<T>): Expr<T>;
    not(a: Expr<T>): Expr<T>;
    or(a: Expr<T>, b: Expr<T>): Expr<T>;
}

// Warning: (ae-forgotten-export) The symbol "TagToType" needs to be exported by the entry point index.d.ts
//
// @public
export type InferSchema<S> = S extends SchemaTag ? TagToType<S> : S extends {
    __tag: "array";
    of: infer U;
} ? InferSchema<U>[] : S extends {
    __tag: "nullable";
    of: infer U;
} ? InferSchema<U> | null : S extends Record<string, unknown> ? {
    [K in keyof S]: InferSchema<S[K]>;
} : never;

// @public
export function inferType(node: ASTNode, impls: TraitImpl[], schema?: Record<string, unknown>): string | null;

// @public
export function injectLambdaParam(node: any, name: string, value: unknown): void;

// @public
export type Interpreter = (program: Program) => {
    run: (input: Record<string, unknown>) => Promise<unknown>;
};

// @public
export interface InterpreterFragment {
    // (undocumented)
    canHandle: (node: ASTNode) => boolean;
    isVolatile?: (node: ASTNode) => boolean;
    // (undocumented)
    pluginName: string;
    // (undocumented)
    visit: (node: ASTNode) => Generator<StepEffect, unknown, unknown>;
}

// @public
export interface LegacyInterpreterFragment {
    // (undocumented)
    canHandle: (node: ASTNode) => boolean;
    // (undocumented)
    pluginName: string;
    // (undocumented)
    visit: (node: ASTNode, recurse: (node: ASTNode) => Promise<unknown>) => Promise<unknown>;
}

// Warning: (ae-internal-missing-underscore) The name "MissingTraitError" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface MissingTraitError<_TraitName extends string, Hint extends string> {
    // @deprecated (undocumented)
    readonly __error: Hint;
}

// Warning: (ae-incompatible-release-tags) The symbol "monoid" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const monoid: PluginDefinition<TypeclassSlot<"monoid">>;

// @public
export interface MonoidFor<_T> {
}

// @public
export function mvfm<P extends PluginDefinition<any, any>[]>(...plugins: P): {
    <S extends SchemaShape>(schema: S, fn: ($: CoreDollar<InferSchema<S>> & MergePlugins<P>) => Expr<any> | any): Program;
    <I = never>(fn: ($: CoreDollar<I> & MergePlugins<P>) => Expr<any> | any): Program;
};

// @public
export function nullable(of: SchemaType): NullableSchema;

// @public
export interface NullableSchema {
    // (undocumented)
    readonly __tag: "nullable";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export const num: PluginDefinition<NumMethods, {
    eq: number;
    ord: number;
    semiring: number;
    show: number;
    bounded: number;
}>;

// @public
export const numInterpreter: InterpreterFragment;

// @public
export interface NumMethods {
    abs(a: Expr<number> | number): Expr<number>;
    ceil(a: Expr<number> | number): Expr<number>;
    div(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    floor(a: Expr<number> | number): Expr<number>;
    max(...values: (Expr<number> | number)[]): Expr<number>;
    min(...values: (Expr<number> | number)[]): Expr<number>;
    mod(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    neg(a: Expr<number> | number): Expr<number>;
    round(a: Expr<number> | number): Expr<number>;
    sub(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
}

// Warning: (ae-incompatible-release-tags) The symbol "ord" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const ord: PluginDefinition<TypeclassSlot<"ord">>;

// @public
export interface OrdFor<T> {
    compare(a: Expr<T> | T, b: Expr<T> | T): Expr<number>;
    gt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    gte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const ordInterpreter: InterpreterFragment;

// @public
type Plugin_2<T = any, Traits extends Record<string, unknown> = {}> = PluginDefinition<T, Traits> | (() => PluginDefinition<T, Traits>);
export { Plugin_2 as Plugin }

// @public
export interface PluginContext {
    emit: (node: ASTNode) => void;
    expr: <T>(node: ASTNode) => Expr<T>;
    inputSchema?: Record<string, unknown>;
    isExpr: (value: unknown) => value is Expr<unknown>;
    lift: <T>(value: T | Expr<T>) => Expr<T>;
    plugins: PluginDefinition[];
    _registry: Map<number, ASTNode>;
    statements: ASTNode[];
}

// @public
export interface PluginDefinition<T = any, Traits extends Record<string, unknown> = {}> {
    // (undocumented)
    build: (ctx: PluginContext) => T;
    // (undocumented)
    name: string;
    // (undocumented)
    nodeKinds: string[];
    // (undocumented)
    traits?: {
        eq?: TraitImpl;
        ord?: TraitImpl;
        semiring?: TraitImpl;
        heytingAlgebra?: TraitImpl;
        show?: TraitImpl;
        semigroup?: TraitImpl;
        monoid?: TraitImpl;
        bounded?: TraitImpl;
    };
}

// @public
export interface Program {
    // (undocumented)
    ast: ASTNode;
    // (undocumented)
    hash: string;
    // (undocumented)
    inputSchema: Record<string, unknown>;
    // (undocumented)
    plugins: string[];
}

// @public
export interface RecurseFn {
    (node: ASTNode): Promise<unknown>;
    fresh(): RecurseFn;
}

// @public
export function resolveSchemaType(node: ASTNode, schema?: Record<string, unknown>): string | null;

// @public
export function runAST<S>(root: ASTNode, fragments: InterpreterFragment[], handler: StepHandler<S>, initialState: S): Promise<{
    value: unknown;
    state: S;
}>;

// @public
export type SchemaShape = Record<string, SchemaType>;

// @public
export type SchemaTag = "string" | "number" | "boolean" | "date" | "null";

// @public
export type SchemaType = SchemaTag | ArraySchema | NullableSchema | {
    readonly [key: string]: SchemaType;
};

// Warning: (ae-incompatible-release-tags) The symbol "semigroup" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const semigroup: PluginDefinition<TypeclassSlot<"semigroup">>;

// @public
export interface SemigroupFor<T> {
    append(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// Warning: (ae-incompatible-release-tags) The symbol "semiring" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const semiring: PluginDefinition<TypeclassSlot<"semiring">>;

// @public
export interface SemiringFor<T> {
    add(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
    mul(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// Warning: (ae-incompatible-release-tags) The symbol "show" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const show: PluginDefinition<TypeclassSlot<"show">>;

// @public
export interface ShowFor<T> {
    show(a: Expr<T> | T): Expr<string>;
}

// @public
export const st: PluginDefinition<StMethods>;

// @public
export type Step<S> = {
    done: true;
    value: unknown;
    state: S;
} | {
    done: false;
    node: ASTNode;
    effect: StepEffect;
    context: StepContext;
    state: S;
};

// @public
export interface StepContext {
    depth: number;
    parentNode?: ASTNode;
    path: string[];
}

// @public
export type StepEffect = {
    type: "recurse";
    child: ASTNode;
} | {
    type: string;
    [key: string]: unknown;
};

// @public
export type StepHandler<S> = (effect: StepEffect, context: StepContext, state: S) => Promise<{
    value: unknown;
    state: S;
}>;

// @public
export class Stepper {
    constructor(fragments: InterpreterFragment[], root: ASTNode);
    descend(child: ASTNode, parentNode: ASTNode | undefined): Step<undefined> | null;
    fresh(root: ASTNode): Stepper;
    tick(lastResult?: unknown): Step<undefined> | null;
}

// @public
export interface StMethods {
    let<T>(initial: Expr<T> | T): {
        get: () => Expr<T>;
        set: (value: Expr<T> | T) => void;
        push: (value: Expr<T>) => void;
    };
}

// @public
export const str: PluginDefinition<StrMethods, {
    eq: string;
    show: string;
    semigroup: string;
    monoid: string;
}>;

// @public
export const strInterpreter: InterpreterFragment;

// @public
export interface StrMethods {
    concat(...parts: (Expr<string> | string)[]): Expr<string>;
    endsWith(s: Expr<string> | string, suffix: Expr<string> | string): Expr<boolean>;
    includes(haystack: Expr<string> | string, needle: Expr<string> | string): Expr<boolean>;
    join(arr: Expr<string[]>, separator: Expr<string> | string): Expr<string>;
    len(s: Expr<string> | string): Expr<number>;
    lower(s: Expr<string> | string): Expr<string>;
    replace(s: Expr<string> | string, search: Expr<string> | string, replacement: Expr<string> | string): Expr<string>;
    slice(s: Expr<string> | string, start: Expr<number> | number, end?: Expr<number> | number): Expr<string>;
    split(s: Expr<string> | string, delimiter: Expr<string> | string): Expr<string[]>;
    startsWith(s: Expr<string> | string, prefix: Expr<string> | string): Expr<boolean>;
    str(strings: TemplateStringsArray, ...exprs: (Expr<any> | string | number)[]): Expr<string>;
    trim(s: Expr<string> | string): Expr<string>;
    upper(s: Expr<string> | string): Expr<string>;
}

// @public
export interface TraitImpl {
    // (undocumented)
    nodeKinds: Record<string, string>;
    // (undocumented)
    type: string;
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassMapping" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassMapping<T> {
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassSlot" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassSlot<Name extends string> {
    // (undocumented)
    readonly __typeclassSlot: Name;
}

// Warnings were encountered during analysis:
//
// dist/core.d.ts:419:5 - (ae-forgotten-export) The symbol "CoreDollar" needs to be exported by the entry point index.d.ts
// dist/core.d.ts:419:5 - (ae-forgotten-export) The symbol "MergePlugins" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
