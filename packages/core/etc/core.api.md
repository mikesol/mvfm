## API Report File for "@mvfm/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function array(of: SchemaType): ArraySchema;

// @public
export interface ArraySchema {
    // (undocumented)
    readonly __tag: "array";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export const boolean: PluginDefinition<BooleanMethods, {
    eq: boolean;
    show: boolean;
    heytingAlgebra: boolean;
    bounded: boolean;
}>;

// @public
export const booleanInterpreter: Interpreter;

// @public
export type BooleanMethods = {};

// Warning: (ae-incompatible-release-tags) The symbol "bounded" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const bounded: PluginDefinition<TypeclassSlot<"bounded">>;

// @public
export interface BoundedFor<_T> {
}

// @public
export function checkCompleteness(interpreter: Interpreter, root: TypedNode): void;

// @public
export type CompleteInterpreter<K extends string> = {
    [key in K]: (node: any) => AsyncGenerator<TypedNode, unknown, unknown>;
};

// @public
export const control: PluginDefinition<ControlMethods>;

// @public
export interface ControlMethods {
    each<T>(collection: Expr<T[]>, body: (item: Expr<T>) => void): void;
    while(condition: Expr<boolean>): {
        body: (...statements: unknown[]) => void;
    };
}

// @public
export const coreInterpreter: Interpreter;

// @public
export function createFoldState(): FoldState;

// Warning: (ae-incompatible-release-tags) The symbol "eq" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const eq: PluginDefinition<TypeclassSlot<"eq">>;

// @public
export interface EqFor<T> {
    eq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    neq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const eqInterpreter: Interpreter;

// @public
export const error: PluginDefinition<ErrorMethods>;

// @public
export const errorInterpreter: Interpreter;

// @public
export interface ErrorMethods {
    attempt<T>(expr: Expr<T>): Expr<{
        ok: T | null;
        err: any | null;
    }>;
    fail(error: Expr<any> | any): Expr<never>;
    guard(condition: Expr<boolean>, error: Expr<any> | any): Expr<void>;
    orElse<T>(expr: Expr<T>, fallback: Expr<T> | T): Expr<T>;
    settle(...exprs: Expr<any>[]): Expr<{
        fulfilled: any[];
        rejected: any[];
    }>;
    // Warning: (ae-forgotten-export) The symbol "TryBuilder" needs to be exported by the entry point index.d.ts
    try<T>(expr: Expr<T>): TryBuilder<T>;
}

// @public
export function eval_<T>(node: TypedNode<T>): AsyncGenerator<TypedNode, T, unknown>;

// Warning: (ae-forgotten-export) The symbol "ExprBase" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExprFields" needs to be exported by the entry point index.d.ts
//
// @public
export type Expr<T> = ExprBase<T> & ExprFields<T>;

// @public
export const fiber: PluginDefinition<FiberMethods>;

// @public
export const fiberInterpreter: Interpreter;

// @public
export interface FiberMethods {
    // Warning: (ae-forgotten-export) The symbol "ParFn" needs to be exported by the entry point index.d.ts
    par: ParFn;
    race(...exprs: Expr<any>[]): Expr<any>;
    retry(expr: Expr<any>, opts: {
        attempts: number;
        delay?: number;
    }): Expr<any>;
    seq(...exprs: (Expr<any> | any)[]): Expr<any>;
    timeout(expr: Expr<any>, ms: number | Expr<number>, fallback: Expr<any> | any): Expr<any>;
}

// @public
export function foldAST(interpreter: Interpreter, root: TypedNode, state?: FoldState): Promise<unknown>;

// @public
export interface FoldState {
    // (undocumented)
    cache: WeakMap<TypedNode, unknown>;
    // (undocumented)
    tainted: WeakSet<TypedNode>;
}

// @public
export type Handler<N extends TypedNode<any>> = N extends TypedNode<infer T> ? (node: N) => AsyncGenerator<TypedNode, T, unknown> : never;

// Warning: (ae-incompatible-release-tags) The symbol "heytingAlgebra" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const heytingAlgebra: PluginDefinition<TypeclassSlot<"heytingAlgebra">>;

// @public
export interface HeytingAlgebraFor<T> {
    and(a: Expr<T>, b: Expr<T>): Expr<T>;
    not(a: Expr<T>): Expr<T>;
    or(a: Expr<T>, b: Expr<T>): Expr<T>;
}

// Warning: (ae-forgotten-export) The symbol "TagToType" needs to be exported by the entry point index.d.ts
//
// @public
export type InferSchema<S> = S extends SchemaTag ? TagToType<S> : S extends {
    __tag: "array";
    of: infer U;
} ? InferSchema<U>[] : S extends {
    __tag: "nullable";
    of: infer U;
} ? InferSchema<U> | null : S extends Record<string, unknown> ? {
    [K in keyof S]: InferSchema<S[K]>;
} : never;

// @public
export function inferType(node: any, impls: TraitImpl[], schema?: Record<string, unknown>): string | null;

// @public
export function injectLambdaParam(node: any, name: string, value: unknown): void;

// @public
export type Interpreter = Record<string, (node: any) => AsyncGenerator<TypedNode, unknown, unknown>>;

// Warning: (ae-internal-missing-underscore) The name "MissingTraitError" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface MissingTraitError<_TraitName extends string, Hint extends string> {
    // @deprecated (undocumented)
    readonly __error: Hint;
}

// Warning: (ae-incompatible-release-tags) The symbol "monoid" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const monoid: PluginDefinition<TypeclassSlot<"monoid">>;

// @public
export interface MonoidFor<_T> {
}

// @public
export function mvfm<const P extends readonly PluginInput[]>(...plugins: P): {
    <S extends SchemaShape>(schema: S, fn: ($: CoreDollar<InferSchema<S>> & MergePlugins<FlattenPluginInputs<P>>) => Expr<any> | any): Program;
    <I = never>(fn: ($: CoreDollar<I> & MergePlugins<FlattenPluginInputs<P>>) => Expr<any> | any): Program;
};

// @public
export function nullable(of: SchemaType): NullableSchema;

// @public
export interface NullableSchema {
    // (undocumented)
    readonly __tag: "nullable";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export const num: PluginDefinition<NumMethods, {
    eq: number;
    ord: number;
    semiring: number;
    show: number;
    bounded: number;
}>;

// @public
export const numInterpreter: Interpreter;

// @public
export interface NumMethods {
    abs(a: Expr<number> | number): Expr<number>;
    ceil(a: Expr<number> | number): Expr<number>;
    div(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    floor(a: Expr<number> | number): Expr<number>;
    max(...values: (Expr<number> | number)[]): Expr<number>;
    min(...values: (Expr<number> | number)[]): Expr<number>;
    mod(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    neg(a: Expr<number> | number): Expr<number>;
    round(a: Expr<number> | number): Expr<number>;
    sub(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
}

// Warning: (ae-incompatible-release-tags) The symbol "ord" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const ord: PluginDefinition<TypeclassSlot<"ord">>;

// @public
export interface OrdFor<T> {
    compare(a: Expr<T> | T, b: Expr<T> | T): Expr<number>;
    gt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    gte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const ordInterpreter: Interpreter;

// @public
type Plugin_2<T = any, Traits extends Record<string, unknown> = {}> = PluginDefinition<T, Traits> | (() => PluginDefinition<T, Traits>);
export { Plugin_2 as Plugin }

// @public
export interface PluginContext {
    emit: (node: any) => void;
    expr: <T>(node: any) => Expr<T>;
    inputSchema?: Record<string, unknown>;
    isExpr: (value: unknown) => value is Expr<unknown>;
    lift: <T>(value: T | Expr<T>) => Expr<T>;
    plugins: PluginDefinition[];
    _registry: Map<number, any>;
    statements: any[];
}

// @public
export interface PluginDefinition<T = any, Traits extends Record<string, unknown> = {}> {
    // (undocumented)
    build: (ctx: PluginContext) => T;
    // (undocumented)
    name: string;
    // (undocumented)
    nodeKinds: string[];
    // (undocumented)
    traits?: {
        eq?: TraitImpl;
        ord?: TraitImpl;
        semiring?: TraitImpl;
        heytingAlgebra?: TraitImpl;
        show?: TraitImpl;
        semigroup?: TraitImpl;
        monoid?: TraitImpl;
        bounded?: TraitImpl;
    };
}

// @public
export type PluginInput = Plugin_2 | readonly PluginInput[];

// Warning: (ae-incompatible-release-tags) The symbol "prelude" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const prelude: readonly [PluginDefinition<NumMethods, {
eq: number;
ord: number;
semiring: number;
show: number;
bounded: number;
}>, PluginDefinition<StrMethods, {
eq: string;
show: string;
semigroup: string;
monoid: string;
}>, PluginDefinition<TypeclassSlot<"semiring">, {}>, PluginDefinition<TypeclassSlot<"eq">, {}>, PluginDefinition<TypeclassSlot<"ord">, {}>, PluginDefinition<TypeclassSlot<"show">, {}>, PluginDefinition<BooleanMethods, {
eq: boolean;
show: boolean;
heytingAlgebra: boolean;
bounded: boolean;
}>, PluginDefinition<TypeclassSlot<"bounded">, {}>, PluginDefinition<TypeclassSlot<"heytingAlgebra">, {}>, PluginDefinition<TypeclassSlot<"semigroup">, {}>, PluginDefinition<TypeclassSlot<"monoid">, {}>];

// @public
export interface Program {
    // (undocumented)
    ast: any;
    // (undocumented)
    hash: string;
    // (undocumented)
    inputSchema: Record<string, unknown>;
    // (undocumented)
    plugins: string[];
}

// @public
export function resolveSchemaType(node: any, schema?: Record<string, unknown>): string | null;

// @public
export type SchemaShape = Record<string, SchemaType>;

// @public
export type SchemaTag = "string" | "number" | "boolean" | "date" | "null";

// @public
export type SchemaType = SchemaTag | ArraySchema | NullableSchema | {
    readonly [key: string]: SchemaType;
};

// Warning: (ae-incompatible-release-tags) The symbol "semigroup" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const semigroup: PluginDefinition<TypeclassSlot<"semigroup">>;

// @public
export interface SemigroupFor<T> {
    append(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// Warning: (ae-incompatible-release-tags) The symbol "semiring" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const semiring: PluginDefinition<TypeclassSlot<"semiring">>;

// @public
export interface SemiringFor<T> {
    add(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
    mul(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// Warning: (ae-incompatible-release-tags) The symbol "show" is marked as @public, but its signature references "TypeclassSlot" which is marked as @internal
//
// @public
export const show: PluginDefinition<TypeclassSlot<"show">>;

// @public
export interface ShowFor<T> {
    show(a: Expr<T> | T): Expr<string>;
}

// @public
export const st: PluginDefinition<StMethods>;

// @public
export interface StMethods {
    let<T>(initial: Expr<T> | T): {
        get: () => Expr<T>;
        set: (value: Expr<T> | T) => void;
        push: (value: Expr<T>) => void;
    };
}

// @public
export const str: PluginDefinition<StrMethods, {
    eq: string;
    show: string;
    semigroup: string;
    monoid: string;
}>;

// @public
export const strInterpreter: Interpreter;

// @public
export interface StrMethods {
    concat(...parts: (Expr<string> | string)[]): Expr<string>;
    endsWith(s: Expr<string> | string, suffix: Expr<string> | string): Expr<boolean>;
    includes(haystack: Expr<string> | string, needle: Expr<string> | string): Expr<boolean>;
    join(arr: Expr<string[]>, separator: Expr<string> | string): Expr<string>;
    len(s: Expr<string> | string): Expr<number>;
    lower(s: Expr<string> | string): Expr<string>;
    replace(s: Expr<string> | string, search: Expr<string> | string, replacement: Expr<string> | string): Expr<string>;
    slice(s: Expr<string> | string, start: Expr<number> | number, end?: Expr<number> | number): Expr<string>;
    split(s: Expr<string> | string, delimiter: Expr<string> | string): Expr<string[]>;
    startsWith(s: Expr<string> | string, prefix: Expr<string> | string): Expr<boolean>;
    str(strings: TemplateStringsArray, ...exprs: (Expr<any> | string | number)[]): Expr<string>;
    trim(s: Expr<string> | string): Expr<string>;
    upper(s: Expr<string> | string): Expr<string>;
}

// @public
export interface TraitImpl {
    // (undocumented)
    nodeKinds: Record<string, string>;
    // (undocumented)
    type: string;
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassMapping" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassMapping<T> {
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassSlot" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassSlot<Name extends string> {
    // (undocumented)
    readonly __typeclassSlot: Name;
}

// @public
export function typedFoldAST<K extends string>(program: TypedProgram<K>, interpreter: CompleteInterpreter<K>, state?: FoldState): Promise<unknown>;

// @public
export interface TypedNode<T = unknown> {
    // (undocumented)
    readonly __T?: T;
    // (undocumented)
    readonly kind: string;
}

// @public
export interface TypedProgram<K extends string> {
    // (undocumented)
    readonly __kinds?: K;
    // (undocumented)
    root: TypedNode;
}

// @public
export const VOLATILE_KINDS: Set<string>;

// Warnings were encountered during analysis:
//
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "CoreDollar" needs to be exported by the entry point index.d.ts
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "MergePlugins" needs to be exported by the entry point index.d.ts
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "FlattenPluginInputs" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
