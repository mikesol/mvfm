## API Report File for "@mvfm/core"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export function array(of: SchemaType): ArraySchema;

// @public
export interface ArraySchema {
    // (undocumented)
    readonly __tag: "array";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export const boolean: PluginDefinition<BooleanMethods, {}, "boolean/and" | "boolean/or" | "boolean/not" | "boolean/eq" | "boolean/ff" | "boolean/tt" | "boolean/implies" | "boolean/show" | "boolean/top" | "boolean/bottom">;

// Warning: (ae-forgotten-export) The symbol "BooleanKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const booleanInterpreter: Interpreter<BooleanKinds>;

// @public
export type BooleanMethods = {};

// @public
export const bounded: PluginDefinition<any, {}, never>;

// @public
export interface BoundedFor<_T> {
}

// @public
export function checkCompleteness(interpreter: Interpreter, program: Program): void;

// @public (undocumented)
export function checkCompleteness(interpreter: Interpreter, root: TypedNode): void;

// @public
export const control: PluginDefinition<ControlMethods, {}, "control/each" | "control/while">;

// @public
export const controlInterpreter: Interpreter<"control/each" | "control/while">;

// @public
export interface ControlMethods {
    each<T>(collection: Expr<T[]>, body: (item: Expr<T>) => void): void;
    while(condition: Expr<boolean>): {
        body: (...statements: unknown[]) => void;
    };
}

// @public
export interface CoreBegin<T = unknown> extends TypedNode<T> {
    // (undocumented)
    kind: "core/begin";
    // (undocumented)
    result: TypedNode<T>;
    // (undocumented)
    steps: TypedNode[];
}

// @public
export interface CoreCond<T = unknown> extends TypedNode<T> {
    // (undocumented)
    else: TypedNode<T>;
    // (undocumented)
    kind: "core/cond";
    // (undocumented)
    predicate: TypedNode<boolean>;
    // (undocumented)
    then: TypedNode<T>;
}

// @public
export interface CoreInput extends TypedNode<unknown> {
    // (undocumented)
    __inputData?: unknown;
    // (undocumented)
    kind: "core/input";
}

// @public
export const coreInterpreter: Interpreter<"core/literal" | "core/input" | "core/prop_access" | "core/record" | "core/cond" | "core/begin" | "core/program" | "core/tuple" | "core/lambda_param">;

// @public
export interface CoreLambdaParam<T = unknown> extends TypedNode<T> {
    // (undocumented)
    __value?: T;
    // (undocumented)
    kind: "core/lambda_param";
}

// @public
export interface CoreLiteral<T = unknown> extends TypedNode<T> {
    // (undocumented)
    kind: "core/literal";
    // (undocumented)
    value: T;
}

// @public
export interface CoreProgram extends TypedNode<unknown> {
    // (undocumented)
    kind: "core/program";
    // (undocumented)
    result: TypedNode;
}

// @public
export interface CorePropAccess<T = unknown> extends TypedNode<T> {
    // (undocumented)
    kind: "core/prop_access";
    // (undocumented)
    object: TypedNode<Record<string, unknown>>;
    // (undocumented)
    property: string;
}

// @public
export interface CoreRecord extends TypedNode<Record<string, unknown>> {
    // (undocumented)
    fields: Record<string, TypedNode>;
    // (undocumented)
    kind: "core/record";
}

// @public
export interface CoreTuple extends TypedNode<unknown[]> {
    // (undocumented)
    elements: TypedNode[];
    // (undocumented)
    kind: "core/tuple";
}

// @public
export function createFoldState(): FoldState;

// @public
export function createStInterpreter(): Interpreter<"st/let" | "st/get" | "st/set" | "st/push">;

// Warning: (ae-forgotten-export) The symbol "DefaultsArgs" needs to be exported by the entry point index.d.ts
//
// @public
export function defaults<const P extends readonly PluginInput[]>(app: {
    readonly plugins: P;
}, ...args: DefaultsArgs<P>): Interpreter<ExtractPluginKinds<P[number]>>;

// Warning: (ae-forgotten-export) The symbol "RejectAnyParam" needs to be exported by the entry point index.d.ts
//
// @public
export function defineInterpreter<K extends string>(): <T extends InterpreterHandlers<K>>(handlers: string extends K ? T : T & { [P in K]: P extends keyof T ? RejectAnyParam<P, T[P]> : never; }) => Interpreter<K>;

// @public
export function definePlugin<const Kinds extends readonly string[], T, Traits extends Record<string, unknown> = {}>(def: {
    name: string;
    nodeKinds: Kinds;
    build: (ctx: PluginContext) => T;
    defaultInterpreter?: () => Interpreter<string>;
    traits?: PluginDefinition<any, Traits, Kinds[number]>["traits"];
}): PluginDefinition<T, Traits, Kinds[number]>;

// @public
export const eq: PluginDefinition<any, {}, "eq/neq">;

// @public
export interface EqFor<T> {
    eq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    neq(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const eqInterpreter: Interpreter<"eq/neq">;

// @public
export const error: PluginDefinition<ErrorMethods, {}, "error/try" | "error/fail" | "error/attempt" | "error/guard" | "error/settle">;

// @public
export const errorInterpreter: Interpreter<"error/try" | "error/fail" | "error/attempt" | "error/guard" | "error/settle">;

// @public
export interface ErrorMethods {
    attempt<T>(expr: Expr<T>): Expr<{
        ok: T | null;
        err: any | null;
    }>;
    fail(error: Expr<any> | any): Expr<never>;
    guard(condition: Expr<boolean>, error: Expr<any> | any): Expr<void>;
    orElse<T>(expr: Expr<T>, fallback: Expr<T> | T): Expr<T>;
    settle(...exprs: Expr<any>[]): Expr<{
        fulfilled: any[];
        rejected: any[];
    }>;
    // Warning: (ae-forgotten-export) The symbol "TryBuilder" needs to be exported by the entry point index.d.ts
    try<T>(expr: Expr<T>): TryBuilder<T>;
}

// @public
export function eval_<T>(node: TypedNode<T>): AsyncGenerator<TypedNode, T, unknown>;

// Warning: (ae-forgotten-export) The symbol "ExprBase" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ExprFields" needs to be exported by the entry point index.d.ts
//
// @public
export type Expr<T> = ExprBase<T> & ExprFields<T>;

// @public
export type ExtractPluginKinds<P> = P extends PluginDefinition<any, any, infer K> ? K : P extends (...args: any[]) => PluginDefinition<any, any, infer K> ? K : never;

// @public
export const fiber: PluginDefinition<FiberMethods, {}, "fiber/par_map" | "fiber/race" | "fiber/timeout" | "fiber/retry">;

// Warning: (ae-forgotten-export) The symbol "FiberKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const fiberInterpreter: Interpreter<FiberKinds>;

// @public
export interface FiberMethods {
    // Warning: (ae-forgotten-export) The symbol "ParFn" needs to be exported by the entry point index.d.ts
    par: ParFn;
    race(...exprs: Expr<any>[]): Expr<any>;
    retry(expr: Expr<any>, opts: {
        attempts: number;
        delay?: number;
    }): Expr<any>;
    seq(first: Expr<any> | any, ...rest: (Expr<any> | any)[]): Expr<any>;
    timeout(expr: Expr<any>, ms: number | Expr<number>, fallback: Expr<any> | any): Expr<any>;
}

// @public
export function foldAST<K extends string>(interpreter: Interpreter<K>, program: Program<K>, state?: FoldState): Promise<unknown>;

// @public (undocumented)
export function foldAST<K extends string>(interpreter: Interpreter<K>, root: TypedNode, state?: FoldState): Promise<unknown>;

// @public
export interface FoldState {
    // (undocumented)
    cache: WeakMap<TypedNode, unknown>;
    // (undocumented)
    tainted: WeakSet<TypedNode>;
}

// @public
export type FoldYield = TypedNode | RecurseScopedEffect;

// @public
export type Handler<N extends TypedNode<any>> = N extends TypedNode<infer T> ? (node: N) => AsyncGenerator<FoldYield, T, unknown> : never;

// @public
export const heytingAlgebra: PluginDefinition<any, {}, never>;

// @public
export interface HeytingAlgebraFor<T> {
    and(a: Expr<T>, b: Expr<T>): Expr<T>;
    not(a: Expr<T>): Expr<T>;
    or(a: Expr<T>, b: Expr<T>): Expr<T>;
}

// Warning: (ae-forgotten-export) The symbol "TagToType" needs to be exported by the entry point index.d.ts
//
// @public
export type InferSchema<S> = S extends SchemaTag ? TagToType<S> : S extends {
    __tag: "array";
    of: infer U;
} ? InferSchema<U>[] : S extends {
    __tag: "nullable";
    of: infer U;
} ? InferSchema<U> | null : S extends Record<string, unknown> ? {
    [K in keyof S]: InferSchema<S[K]>;
} : never;

// @public
export function inferType(node: any, impls: TraitImpl[], schema?: Record<string, unknown>): string | null;

// @public
export function injectInput(program: Program, input: Record<string, unknown>): Program;

// @public
export function injectLambdaParam(node: any, name: string, value: unknown): void;

// @public
export type Interpreter<K extends string = string> = InterpreterHandlers<K> & {
    readonly [interpreterBrand]: K;
};

// Warning: (ae-forgotten-export) The symbol "AnyHandlerRecord" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type InterpreterHandlers<K extends string> = string extends K ? AnyHandlerRecord : {
    [P in K]: P extends keyof NodeTypeMap ? Handler<NodeTypeMap[P]> : never;
};

// @public
export type IsAny<T> = 0 extends 1 & T ? true : false;

// @public
export function mergeInterpreters<A extends string, B extends string>(a: Interpreter<A>, b: Interpreter<B>): Interpreter<A | B>;

// Warning: (ae-internal-missing-underscore) The name "MissingTraitError" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface MissingTraitError<_TraitName extends string, Hint extends string> {
    // @deprecated (undocumented)
    readonly __error: Hint;
}

// @public
export const monoid: PluginDefinition<any, {}, never>;

// @public
export interface MonoidFor<_T> {
}

// @public
export function mvfm<const P extends readonly PluginInput[]>(...plugins: P): {
    <S extends SchemaShape>(schema: S, fn: ($: CoreDollar<InferSchema<S>> & MergePlugins<FlattenPluginInputs<P>>) => Expr<any> | any): Program<ExtractPluginKinds<FlattenPluginInputs<P>[number]>>;
    <I = never>(fn: ($: CoreDollar<I> & MergePlugins<FlattenPluginInputs<P>>) => Expr<any> | any): Program<ExtractPluginKinds<FlattenPluginInputs<P>[number]>>;
} & {
    plugins: FlattenPluginInputs<P>;
};

// @public
export interface NodeTypeMap {
}

// @public
export function nullable(of: SchemaType): NullableSchema;

// @public
export interface NullableSchema {
    // (undocumented)
    readonly __tag: "nullable";
    // (undocumented)
    readonly of: SchemaType;
}

// @public
export const num: PluginDefinition<NumMethods, {}, "num/add" | "num/sub" | "num/mul" | "num/div" | "num/mod" | "num/compare" | "num/neg" | "num/abs" | "num/floor" | "num/ceil" | "num/round" | "num/min" | "num/max" | "num/eq" | "num/zero" | "num/one" | "num/show" | "num/top" | "num/bottom">;

// Warning: (ae-forgotten-export) The symbol "NumKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const numInterpreter: Interpreter<NumKinds>;

// @public
export interface NumMethods {
    abs(a: Expr<number> | number): Expr<number>;
    ceil(a: Expr<number> | number): Expr<number>;
    div(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    floor(a: Expr<number> | number): Expr<number>;
    max(...values: (Expr<number> | number)[]): Expr<number>;
    min(...values: (Expr<number> | number)[]): Expr<number>;
    mod(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
    neg(a: Expr<number> | number): Expr<number>;
    round(a: Expr<number> | number): Expr<number>;
    sub(a: Expr<number> | number, b: Expr<number> | number): Expr<number>;
}

// @public
export const ord: PluginDefinition<any, {}, "ord/gt" | "ord/gte" | "ord/lt" | "ord/lte">;

// @public
export interface OrdFor<T> {
    compare(a: Expr<T> | T, b: Expr<T> | T): Expr<number>;
    gt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    gte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lt(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
    lte(a: Expr<T> | T, b: Expr<T> | T): Expr<boolean>;
}

// @public
export const ordInterpreter: Interpreter<"ord/gt" | "ord/gte" | "ord/lt" | "ord/lte">;

// @public
type Plugin_2<T = any, Traits extends Record<string, unknown> = {}> = PluginDefinition<T, Traits, string> | (() => PluginDefinition<T, Traits, string>);
export { Plugin_2 as Plugin }

// @public
export interface PluginContext {
    emit: (node: any) => void;
    expr: <T>(node: any) => Expr<T>;
    inputSchema?: Record<string, unknown>;
    isExpr: (value: unknown) => value is Expr<unknown>;
    lift: <T>(value: T | Expr<T>) => Expr<T>;
    plugins: PluginDefinition<any, Record<string, unknown>, string>[];
    _registry: Map<number, any>;
    statements: any[];
}

// @public
export interface PluginDefinition<T = any, Traits extends Record<string, unknown> = {}, K extends string = string> {
    // @internal
    readonly __traits?: Traits;
    // (undocumented)
    build: (ctx: PluginContext) => T;
    defaultInterpreter?: () => Interpreter<K>;
    // (undocumented)
    name: string;
    // (undocumented)
    nodeKinds: readonly K[];
    // (undocumented)
    traits?: {
        eq?: TraitImpl;
        ord?: TraitImpl;
        semiring?: TraitImpl;
        heytingAlgebra?: TraitImpl;
        show?: TraitImpl;
        semigroup?: TraitImpl;
        monoid?: TraitImpl;
        bounded?: TraitImpl;
    };
}

// @public
export type PluginInput = Plugin_2 | readonly PluginInput[];

// @public
export const prelude: readonly [PluginDefinition<NumMethods, {}, "num/add" | "num/sub" | "num/mul" | "num/div" | "num/mod" | "num/compare" | "num/neg" | "num/abs" | "num/floor" | "num/ceil" | "num/round" | "num/min" | "num/max" | "num/eq" | "num/zero" | "num/one" | "num/show" | "num/top" | "num/bottom">, PluginDefinition<StrMethods, {}, "str/template" | "str/concat" | "str/upper" | "str/lower" | "str/trim" | "str/slice" | "str/includes" | "str/startsWith" | "str/endsWith" | "str/split" | "str/join" | "str/replace" | "str/len" | "str/eq" | "str/show" | "str/append" | "str/mempty">, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, "eq/neq">, PluginDefinition<any, {}, "ord/gt" | "ord/gte" | "ord/lt" | "ord/lte">, PluginDefinition<any, {}, never>, PluginDefinition<BooleanMethods, {}, "boolean/and" | "boolean/or" | "boolean/not" | "boolean/eq" | "boolean/ff" | "boolean/tt" | "boolean/implies" | "boolean/show" | "boolean/top" | "boolean/bottom">, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, never>, PluginDefinition<any, {}, never>];

// @public
export interface Program<K extends string = string> {
    // (undocumented)
    readonly __kinds?: K;
    // (undocumented)
    ast: any;
    // (undocumented)
    hash: string;
    // (undocumented)
    inputSchema: Record<string, unknown>;
    // (undocumented)
    plugins: string[];
}

// @public
export function recurseScoped(child: TypedNode, bindings: ScopedBinding[]): RecurseScopedEffect;

// @public
export interface RecurseScopedEffect {
    // (undocumented)
    bindings: ScopedBinding[];
    // (undocumented)
    child: TypedNode;
    // (undocumented)
    type: "recurse_scoped";
}

// @public
export function resolveSchemaType(node: any, schema?: Record<string, unknown>): string | null;

// @public
export type SchemaShape = Record<string, SchemaType>;

// @public
export type SchemaTag = "string" | "number" | "boolean" | "date" | "null";

// @public
export type SchemaType = SchemaTag | ArraySchema | NullableSchema | {
    readonly [key: string]: SchemaType;
};

// @public
export interface ScopedBinding {
    // (undocumented)
    paramId: number;
    // (undocumented)
    value: unknown;
}

// @public
export const semigroup: PluginDefinition<any, {}, never>;

// @public
export interface SemigroupFor<T> {
    append(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// @public
export const semiring: PluginDefinition<any, {}, never>;

// @public
export interface SemiringFor<T> {
    add(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
    mul(a: Expr<T> | T, b: Expr<T> | T): Expr<T>;
}

// @public
export const show: PluginDefinition<any, {}, never>;

// @public
export interface ShowFor<T> {
    show(a: Expr<T> | T): Expr<string>;
}

// @public
export const st: PluginDefinition<StMethods, {}, "st/let" | "st/get" | "st/set" | "st/push">;

// @public
export const stInterpreter: Interpreter<"st/let" | "st/get" | "st/set" | "st/push">;

// @public
export interface StMethods {
    let<T>(initial: Expr<T> | T): {
        get: () => Expr<T>;
        set: (value: Expr<T> | T) => void;
        push: (value: Expr<T>) => void;
    };
}

// @public
export const str: PluginDefinition<StrMethods, {}, "str/template" | "str/concat" | "str/upper" | "str/lower" | "str/trim" | "str/slice" | "str/includes" | "str/startsWith" | "str/endsWith" | "str/split" | "str/join" | "str/replace" | "str/len" | "str/eq" | "str/show" | "str/append" | "str/mempty">;

// Warning: (ae-forgotten-export) The symbol "StrKinds" needs to be exported by the entry point index.d.ts
//
// @public
export const strInterpreter: Interpreter<StrKinds>;

// @public
export interface StrMethods {
    concat(...parts: (Expr<string> | string)[]): Expr<string>;
    endsWith(s: Expr<string> | string, suffix: Expr<string> | string): Expr<boolean>;
    includes(haystack: Expr<string> | string, needle: Expr<string> | string): Expr<boolean>;
    join(arr: Expr<string[]>, separator: Expr<string> | string): Expr<string>;
    len(s: Expr<string> | string): Expr<number>;
    lower(s: Expr<string> | string): Expr<string>;
    replace(s: Expr<string> | string, search: Expr<string> | string, replacement: Expr<string> | string): Expr<string>;
    slice(s: Expr<string> | string, start: Expr<number> | number, end?: Expr<number> | number): Expr<string>;
    split(s: Expr<string> | string, delimiter: Expr<string> | string): Expr<string[]>;
    startsWith(s: Expr<string> | string, prefix: Expr<string> | string): Expr<boolean>;
    str(strings: TemplateStringsArray, ...exprs: (Expr<any> | string | number)[]): Expr<string>;
    trim(s: Expr<string> | string): Expr<string>;
    upper(s: Expr<string> | string): Expr<string>;
}

// @public
export interface TraitImpl {
    // (undocumented)
    nodeKinds: Record<string, string>;
    // (undocumented)
    type: string;
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassMapping" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassMapping<T> {
}

// Warning: (ae-internal-missing-underscore) The name "TypeclassSlot" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export interface TypeclassSlot<Name extends string> {
    // (undocumented)
    readonly __typeclassSlot: Name;
}

// @public
export interface TypedNode<T = unknown> {
    // (undocumented)
    readonly __T?: T;
    // (undocumented)
    readonly kind: string;
}

// @public
export const VOLATILE_KINDS: Set<string>;

// Warnings were encountered during analysis:
//
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "CoreDollar" needs to be exported by the entry point index.d.ts
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "MergePlugins" needs to be exported by the entry point index.d.ts
// dist/builder.d.ts:11:5 - (ae-forgotten-export) The symbol "FlattenPluginInputs" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
