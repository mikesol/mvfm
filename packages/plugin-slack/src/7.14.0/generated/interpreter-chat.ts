// AUTO-GENERATED by scripts/codegen.ts â€” do not edit

import type { Interpreter, TypedNode } from "@mvfm/core";
import { defineInterpreter, eval_ } from "@mvfm/core";
import type { SLACK_NODE_KINDS_CHAT } from "./node-kinds-chat";

type SlackChatKind = (typeof SLACK_NODE_KINDS_CHAT)[number];

interface SlackChatBaseNode<K extends SlackChatKind = SlackChatKind> extends TypedNode<unknown> {
  kind: K;
  params?: TypedNode<Record<string, unknown>> | null;
  config: { token: string };
}

export interface SlackChatAppendStreamNode extends SlackChatBaseNode<"slack/chat_appendStream"> {}
export interface SlackChatDeleteNode extends SlackChatBaseNode<"slack/chat_delete"> {}
export interface SlackChatDeleteScheduledMessageNode
  extends SlackChatBaseNode<"slack/chat_deleteScheduledMessage"> {}
export interface SlackChatGetPermalinkNode extends SlackChatBaseNode<"slack/chat_getPermalink"> {}
export interface SlackChatMeMessageNode extends SlackChatBaseNode<"slack/chat_meMessage"> {}
export interface SlackChatPostEphemeralNode extends SlackChatBaseNode<"slack/chat_postEphemeral"> {}
export interface SlackChatPostMessageNode extends SlackChatBaseNode<"slack/chat_postMessage"> {}
export interface SlackChatScheduleMessageNode
  extends SlackChatBaseNode<"slack/chat_scheduleMessage"> {}
export interface SlackChatScheduledMessagesListNode
  extends SlackChatBaseNode<"slack/chat_scheduledMessages_list"> {}
export interface SlackChatStartStreamNode extends SlackChatBaseNode<"slack/chat_startStream"> {}
export interface SlackChatStopStreamNode extends SlackChatBaseNode<"slack/chat_stopStream"> {}
export interface SlackChatUnfurlNode extends SlackChatBaseNode<"slack/chat_unfurl"> {}
export interface SlackChatUpdateNode extends SlackChatBaseNode<"slack/chat_update"> {}

export const NODE_TO_METHOD_CHAT: Record<string, string> = {
  "slack/chat_appendStream": "chat.appendStream",
  "slack/chat_delete": "chat.delete",
  "slack/chat_deleteScheduledMessage": "chat.deleteScheduledMessage",
  "slack/chat_getPermalink": "chat.getPermalink",
  "slack/chat_meMessage": "chat.meMessage",
  "slack/chat_postEphemeral": "chat.postEphemeral",
  "slack/chat_postMessage": "chat.postMessage",
  "slack/chat_scheduleMessage": "chat.scheduleMessage",
  "slack/chat_scheduledMessages_list": "chat.scheduledMessages.list",
  "slack/chat_startStream": "chat.startStream",
  "slack/chat_stopStream": "chat.stopStream",
  "slack/chat_unfurl": "chat.unfurl",
  "slack/chat_update": "chat.update",
};

declare module "@mvfm/core" {
  interface NodeTypeMap {
    "slack/chat_appendStream": SlackChatAppendStreamNode;
    "slack/chat_delete": SlackChatDeleteNode;
    "slack/chat_deleteScheduledMessage": SlackChatDeleteScheduledMessageNode;
    "slack/chat_getPermalink": SlackChatGetPermalinkNode;
    "slack/chat_meMessage": SlackChatMeMessageNode;
    "slack/chat_postEphemeral": SlackChatPostEphemeralNode;
    "slack/chat_postMessage": SlackChatPostMessageNode;
    "slack/chat_scheduleMessage": SlackChatScheduleMessageNode;
    "slack/chat_scheduledMessages_list": SlackChatScheduledMessagesListNode;
    "slack/chat_startStream": SlackChatStartStreamNode;
    "slack/chat_stopStream": SlackChatStopStreamNode;
    "slack/chat_unfurl": SlackChatUnfurlNode;
    "slack/chat_update": SlackChatUpdateNode;
  }
}

interface SlackClientLike {
  apiCall(method: string, params?: Record<string, unknown>): Promise<unknown>;
}

export function createSlackChatInterpreter(client: SlackClientLike): Interpreter {
  const handler = async function* (node: SlackChatBaseNode) {
    const method = NODE_TO_METHOD_CHAT[node.kind];
    if (!method) throw new Error(`Slack interpreter: unknown node kind "${node.kind}"`);
    const params = node.params != null ? yield* eval_(node.params) : undefined;
    return await client.apiCall(method, params);
  };

  return defineInterpreter<SlackChatKind>()({
    "slack/chat_appendStream": async function* (node: SlackChatAppendStreamNode) {
      return yield* handler(node);
    },
    "slack/chat_delete": async function* (node: SlackChatDeleteNode) {
      return yield* handler(node);
    },
    "slack/chat_deleteScheduledMessage": async function* (
      node: SlackChatDeleteScheduledMessageNode,
    ) {
      return yield* handler(node);
    },
    "slack/chat_getPermalink": async function* (node: SlackChatGetPermalinkNode) {
      return yield* handler(node);
    },
    "slack/chat_meMessage": async function* (node: SlackChatMeMessageNode) {
      return yield* handler(node);
    },
    "slack/chat_postEphemeral": async function* (node: SlackChatPostEphemeralNode) {
      return yield* handler(node);
    },
    "slack/chat_postMessage": async function* (node: SlackChatPostMessageNode) {
      return yield* handler(node);
    },
    "slack/chat_scheduleMessage": async function* (node: SlackChatScheduleMessageNode) {
      return yield* handler(node);
    },
    "slack/chat_scheduledMessages_list": async function* (
      node: SlackChatScheduledMessagesListNode,
    ) {
      return yield* handler(node);
    },
    "slack/chat_startStream": async function* (node: SlackChatStartStreamNode) {
      return yield* handler(node);
    },
    "slack/chat_stopStream": async function* (node: SlackChatStopStreamNode) {
      return yield* handler(node);
    },
    "slack/chat_unfurl": async function* (node: SlackChatUnfurlNode) {
      return yield* handler(node);
    },
    "slack/chat_update": async function* (node: SlackChatUpdateNode) {
      return yield* handler(node);
    },
  });
}
