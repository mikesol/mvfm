# S3 Plugin Design

**Date:** 2026-02-13
**Issue:** #53
**Parent:** #46
**Status:** Approved

## Goal

Implement the `s3` plugin modeling `@aws-sdk/client-s3` v3.989.0. The plugin targets "prove the pattern" scope: 5 core object operations covering 80%+ of real-world S3 usage.

## Source-Level Analysis

Cloned `aws-sdk-js-v3` at tag `v3.989.0` and read the S3 client source.

### Architecture

The SDK uses a Smithy-generated command pattern:
- `S3Client` is the low-level client (`client.send(new PutObjectCommand(input))`)
- `S3` is the high-level aggregated client (`s3.putObject(input)`) — a thin wrapper generated by `createAggregatedClient`
- Each command has typed `CommandInput` / `CommandOutput` interfaces
- 108 total commands

### Assessment Matrix

| Category | Operations | Count |
|----------|-----------|-------|
| **Maps cleanly** | All object CRUD (PutObject, GetObject, DeleteObject, HeadObject, CopyObject, DeleteObjects, RenameObject), listing (ListObjectsV2, ListBuckets), all bucket config commands | ~100 |
| **Needs deviation** | GetObject Body — real SDK returns streaming Body; ilo handler converts to string/buffer before returning | 1 |
| **Can't model** | SelectObjectContent (event stream output), multipart upload as a workflow (stateful multi-step) | 2 |

### Plugin Sizing

108 commands total. Core modelable object operations: ~15-20. Bucket config commands: ~80 (mechanical Get/Put pairs).

**Plugin size: LARGE** — 60/30/10 split.
- **Pass 1 (this issue):** 5 core object operations
- **Pass 2:** Additional object ops (CopyObject, DeleteObjects, GetObjectAttributes, tagging) + bucket CRUD
- **Pass 3:** Bucket configuration commands (lifecycle, CORS, encryption, etc.)

## Design Decisions

### Uniform effect (like Stripe)

S3 is pure request-response. Every operation sends a command input and gets a command output. No scoping, no transactions, no statefulness. One effect type: `s3/command`.

### API shape mirrors the aggregated S3 client

The ilo API uses the same method names and parameter shapes as the high-level `S3` class:

```ts
// Real SDK
const s3 = new S3({ region: "us-east-1" });
await s3.putObject({ Bucket: "my-bucket", Key: "file.txt", Body: "hello" });

// Ilo
const app = ilo(num, str, s3({ region: "us-east-1" }));
app(($) => $.s3.putObject({ Bucket: "my-bucket", Key: "file.txt", Body: "hello" }));
```

Method names: `putObject`, `getObject`, `deleteObject`, `headObject`, `listObjectsV2` — identical to the real SDK. PascalCase parameter names (`Bucket`, `Key`, `Body`, `Prefix`) — identical to the real SDK.

### Config

```ts
export interface S3Config {
  region: string;
  credentials?: {
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken?: string;
  };
  endpoint?: string;       // For S3-compatible services (MinIO, LocalStack)
  forcePathStyle?: boolean; // For local dev with MinIO/LocalStack
}
```

Config is baked into every AST node (standard ilo pattern).

### Version directory

`src/plugins/s3/3.989.0/` — matching the npm package version exactly.

### GetObject Body handling

The real SDK returns `Body` as a `ReadableStream`/`Readable`. The ilo handler will call `response.Body.transformToString()` (or `transformToByteArray()` for binary) before returning. The AST result contains the body content directly. This is a deviation but unavoidable — AST results must be serializable.

## Pass 1 Operations (5 operations, 5 node kinds)

| Operation | Node kind | Effect shape |
|-----------|-----------|-------------|
| `putObject(input)` | `s3/put_object` | `{ type: "s3/command", command: "PutObject", input }` |
| `getObject(input)` | `s3/get_object` | `{ type: "s3/command", command: "GetObject", input }` |
| `deleteObject(input)` | `s3/delete_object` | `{ type: "s3/command", command: "DeleteObject", input }` |
| `headObject(input)` | `s3/head_object` | `{ type: "s3/command", command: "HeadObject", input }` |
| `listObjectsV2(input)` | `s3/list_objects_v2` | `{ type: "s3/command", command: "ListObjectsV2", input }` |

### Effect type

Single uniform effect `s3/command` with:
- `command`: The command name (e.g., `"PutObject"`)
- `input`: The resolved input object

The handler dispatches on `command` to construct the appropriate SDK `Command` class.

## File Structure

```
src/plugins/s3/3.989.0/
  index.ts            # PluginDefinition + S3Config + S3Methods types
  interpreter.ts      # InterpreterFragment (s3Interpreter)
  handler.server.ts   # Server handler + serverEvaluate
  handler.client.ts   # Client handler (standard proxy pattern)
  client-aws-sdk.ts   # SDK adapter wrapping S3Client

tests/plugins/s3/3.989.0/
  index.test.ts       # AST construction tests
  interpreter.test.ts # Effect-yielding tests with mock handler
  integration.test.ts # Real tests against LocalStack/MinIO container
```

## Ergonomics Comparison

### WORKS GREAT (1:1 with real SDK)

```ts
// Real:  await s3.putObject({ Bucket: "b", Key: "k", Body: "hello" })
// Ilo:   $.s3.putObject({ Bucket: "b", Key: "k", Body: "hello" })

// Real:  await s3.getObject({ Bucket: "b", Key: "k" })
// Ilo:   $.s3.getObject({ Bucket: "b", Key: "k" })

// Real:  await s3.listObjectsV2({ Bucket: "b", Prefix: "uploads/" })
// Ilo:   $.s3.listObjectsV2({ Bucket: "b", Prefix: "uploads/" })

// Chaining with proxy:
// Real:  const obj = await s3.headObject({ Bucket: "b", Key: "k" });
//        console.log(obj.ContentLength);
// Ilo:   const obj = $.s3.headObject({ Bucket: "b", Key: "k" });
//        const size = obj.ContentLength; // proxy chain
```

### WORKS BUT DIFFERENT

- **GetObject Body**: Real SDK returns streaming Body (`response.Body.transformToString()`). Ilo returns body content directly as string.
- **Return types**: Real SDK has typed response interfaces. Ilo uses `Record<string, unknown>`.

### DOESN'T WORK / NOT MODELED (pass 1)

- **SelectObjectContent**: Event stream output, not request-response.
- **Multipart upload workflow**: Individual commands modelable, but the upload-parts-in-loop workflow needs imperative control flow.
- **Presigned URLs**: Utility function, not a command.
- **Waiters**: `waitUntilObjectExists` — polling-based, not request-response.
